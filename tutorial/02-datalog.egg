;; Datalog is a relational language for deductive reasoning. In the last lesson, we write our first 
;; equality saturation program in egglog, but you can also write Datalog rules in egglog.
;; In this lesson, we will write several classic Datalog programs in egglog. One of the benifits
;; of egglog being a language for program optimization is that it can talk about terms natively,
;; so in egglog we get Datalog with terms for free.

;; In this lesson, we will define multiple relations with the same name,
;; so we use the `(push)/(pop)` commands to clone and reset the database.
;; Under the hood, `(push)` clones the current database and pushes it onto a stack,
;; and `(pop)` resets the database to the top of the stack.
(push)

;; Let's first define relations edge and path.
;; (edge a b) edges are directed edges from a to b,
;; and we will use it to compute the `path` relation,
;; where `path a b` means there is a path from a to b.
(relation edge (i64 i64))
(relation path (i64 i64))

;; We can insert edges into our relation
;; by asserting facts:
(edge 1 2)
(edge 2 3)
(edge 3 4)
;; This is similar to definitions using `(let ..)`,
;; where the fact is immediately added to the database.

;; Now let's tell egglog how to derive the `path` relation.
;;
;; First, if an edge from a to b exists, then it is already a proof
;; that there exists a path from a to b.
(rule ((path a b))
      ((edge a b)))

;; A rule has the form `(rule (atom1 atom2 ..) (action1 action2 ..))`.
;;
;; For the rule we have just defined, the only atom is `(path a b)`, which asks egglog to search
;; for possible `a` and `b`s such that `(path a b)` is a fact in the databaes.
;;
;; We call the first part the "query" of a rule, and the second part the "body" of a rule.
;; In Datalog terminology, confusingly, the first part is called the "body" of the rule
;; while the second part is called the "head" of the rule. This is because Datalog rules
;; are usually written as `head :- body`. To avoid confusion, we will refrain from using
;; Datalog terminology.

;; The rule above defines the base case of the path relation. The inductive case reads as follows:
;; if we know there is a path from `a` to `b`, and there is an edge from `b` to `c`, then
;; there is also a path from `a` to `c`.
;; This can be expressed as egglog rule below:
(rule ((path a b) (edge b c))
      ((path a c)))

;; One thing that may be confusing to people who is familiar with Datalog is that
;; defining a rule does not mean running a rule. In Datalog, a rule is run to a fixpoint,
;; but in egglog, the user still needs to run the program.
;; For instance, the following check would fail at this point.
(fail (check (path 1 4)))

;; Let's run our rules for 10 iterations.
(run 10)
(check (path 1 4)) ; the check passes

;; In many cases, especially for Datalog programs, we do not know the number of iterations
;; needed to reach a fixpoint. Egglog provides the `saturate` scheduling primitive to run the rules until fixpoint.
(run-schedule (saturate (run)))
;; We will cover more details about schedules in TODO.


;; Exercises:
;; 
;; Consider the variant of our last rule:
;; ```
;; (rule ((path a b) (path b c))
;;       ((path a c)))
;; ```
;; Does this rule compute the same relation as the original rule? How does this rule 
;; compare to the original rule? Hint: it's slow, why?

(pop)
(push)
;; Our last example determines whether there is a path from one node to another,
;; but we don't know the details about the path.
;; Let's slightly extend our program to obtain the length of the shortest path between any two nodes.
(function edge (i64 i64) :no-merge)
(function path (i64 i64) :merge (min old new))

;; Here, we use a new keyword called `function` to define a function relation.
;; A function is like a generalization of relation, which can be viewed as a function with output domain `Unit`.
;; This allows us to associate a length to each path.
;;
;; What happens it the same tuple of a function is mapped to two values?
;; In the case of relation, this is easy: `Unit` only has one value, so the two values must be identical.
;; But in general, that would be a violation of functional dependency, the property that `a = b` implies `f(a) = f(b)`.
;; Egglog allows us to specify how to reconcile two values that are mapped from the same tuple using _merge expressions_.
;; For instance, for `path`, the merge expression is `(min old new)`; `old` and `new` are two special values in an expression
;; that denotes the current output of the tuple and the output of the new, to-be-inserted value.
;; The merge expression for `path` says that, when there are two paths from `a` to `b` with lengths `old` and `new`,
;; we keep the shorter one, i.e., `(min old new)`.
;;
;; For `edge`, we can define the merge expression the same as `path`, which means that we only keep the shortest edge
;; if there are multiple edges. But we can also assert that `edge` does not have a merge expression using `no-merge`. 
;; This means we don't expect there will be multiple edges between two nodes. More generally, it is the user's
;; responsibility to ensure no tuples with conflicting output values exist. If a conflict happens, egglog will
;; panic.

;; Now let's insert the same edges as before, but we will assign a length to each edge. This is done using the `set` action,
;; which takes a tuple and an output value:
(set (edge 1 2) 10)
(set (edge 2 3) 10)
(set (edge 1 3) 30)

;; Let us define the reflexive rule and transitive rule for the `path` function.
;; In this rule, we use the `set` action to set the output value of the `path` function.
;; Moreover, on the query side, we use `=` to bind the output value of a function.
(rule ((= (edge x y) len))
      ((set (path x y) len)))
(rule ((= (path x y) xy) 
       (= (edge y z) yz))
      ((set (path x z) (+ xy yz))))

;; Let's run our rules and check we get the desired shortest path.
(run-schedule (saturate (run)))
(check (= (path 1 3) 20))

(pop)
(push)

;; Now let us combine the knowledge we have learned in lessons 1 and 2 to write a program
