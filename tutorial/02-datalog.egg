;; Datalog in egglog

;; Datalog is a relational language for deductive reasoning. In the last lesson, we write our first 
;; equality saturation program in egglog, but you can also write Datalog rules in egglog.
;; In this lesson, we will write several classic Datalog programs in egglog. One of the benifits
;; of egglog being a language for program optimization is that it can talk about terms natively,
;; so in egglog we get Datalog with terms for free.

;; In this lesson, we will define multiple relations with the same name,
;; so we use the `(push)` and `(pop)` commands to checkpoint and reset the database.
;; Under the hood, `(push)` clones the current database and pushes it onto a stack,
;; and `(pop)` resets the database to the top of the stack.
(push)

;; Let's first define relations `edge` and `path`.
;; `(edge a b)` holds directed edges from `a` to `b`,
;; and we will use it to compute the `path` relation,
;; where `path a b` means there is a sequence of
;; directed edges from `a` to `b`.
(relation edge (i64 i64))
(relation path (i64 i64))

;; We can insert edges into our relation by asserting facts:
(edge 1 2)
(edge 2 3)
(edge 3 4)
;; This is similar to definitions using `(let ..)`,
;; where the fact is immediately added to the database.

;; Now let's tell egglog how to derive the `path` relation.
;;
;; First, if an edge from a to b exists, then it is already a proof
;; that there exists a path from a to b.
(rule ((edge a b))
      ((path a b)))

;; A rule has the form `(rule (atom1 atom2 ..) (action1 action2 ..))`.
;;
;; For the rule we have just defined, the only atom is `(path a b)`, which asks egglog to search
;; for possible `a` and `b`s such that `(path a b)` is a fact in the database.
;;
;; We call the first part the "query" of a rule, and the second part the "body" of a rule.
;; In Datalog terminology, confusingly, the first part is called the "body" of the rule
;; while the second part is called the "head" of the rule. This is because Datalog rules
;; are usually written as `head :- body`. To avoid confusion, we will refrain from using
;; Datalog terminology.

;; The rule above defines the base case of the path relation. The inductive case reads as follows:
;; if we know there is a path from `a` to `b`, and there is an edge from `b` to `c`, then
;; there is also a path from `a` to `c`.
;; This can be expressed in egglog using the rule below:
(rule ((path a b) (edge b c))
      ((path a c)))

;; One thing that may be confusing to people who are familiar with Datalog is that
;; defining a rule does not mean running a rule. In Datalog, a rule is run to a fixpoint,
;; but in egglog, the user still needs to run the program.
;; For instance, the following check would fail at this point.
(fail (check (path 1 4)))

;; Let's run our rules for 10 iterations.
; (check (path 1 4)) ; the check fails
(run 10)
(check (path 1 4)) ; the check passes

;; In many cases, especially for Datalog programs, we do not know the number of iterations
;; needed to reach a fixpoint. Egglog provides the `saturate` scheduling primitive to run the rules until fixpoint.
(run-schedule (saturate (run)))
;; We will cover more details about schedules in TODO.


;; Exercises:
;; 
;; Consider the variant of our last rule:
;; ```
;; (rule ((path a b) (path b c))
;;       ((path a c)))
;; ```
;; Does this rule compute the same relation as the original rule? How does this rule 
;; compare to the original rule? Hint: it's slower, but why?

(pop)
(push)
;; Our last example determines whether there is a path from one node to another,
;; but we don't know the details about the path.
;; Let's slightly extend our program to obtain the length of the shortest path between any two nodes.
(function edge (i64 i64) i64 :no-merge)
(function path (i64 i64) i64 :merge (min old new))

;; Here, we use a new keyword called `function` to define a table with a functional dependency.
;; A relation is just a function with output domain `Unit`.
;; By defining `edge` and `path` with `function`, we can associate a length to each path.
;;
;; What happens if a `function` table maps the same inputs to two different output values?
;; In the case of relation, this is easy: `Unit` only has one value, so the two values must be identical.
;; But in general, that would be a violation of functional dependency, the property that `a = b` implies `f(a) = f(b)`.
;; Egglog allows us to specify how to reconcile two values that are mapped from the same tuple using _merge expressions_.
;; For instance, for `path`, the merge expression is `(min old new)`; `old` and `new` are two special values in an expression
;; that denotes the current output of the tuple and the output of the new, to-be-inserted value.
;; The merge expression for `path` says that, when there are two paths from `a` to `b` with lengths `old` and `new`,
;; we keep the shorter one, i.e., `(min old new)`.
;;
;; For `edge`, we can define the merge expression the same as `path`, which means that we only keep the shortest edge
;; if there are multiple edges. But we can also assert that `edge` does not have a merge expression using `no-merge`. 
;; This means we don't expect there will be multiple edges between two nodes. More generally, it is the user's
;; responsibility to ensure no tuples with conflicting output values exist. If a conflict happens, egglog will
;; panic.

;; Now let's insert the same edges as before, but we will assign a length to each edge. This is done using the `set` action,
;; which takes a tuple and an output value:
(set (edge 1 2) 10)
(set (edge 2 3) 10)
(set (edge 1 3) 30)

;; Let us define the reflexive rule and transitive rule for the `path` function.
;; In this rule, we use the `set` action to set the output value of the `path` function.
;; Moreover, on the query side, we use `=` to bind the output value of a function.
(rule ((= (edge x y) len))
      ((set (path x y) len)))
(rule ((= (path x y) xy) 
       (= (edge y z) yz))
      ((set (path x z) (+ xy yz))))

;; Let's run our rules and check we get the desired shortest path.
(run-schedule (saturate (run)))
(check (= (path 1 3) 20))

(pop)
(push)
;; Now let us combine the knowledge we have learned in lessons 1 and 2 to write a program that combines
;; both equality saturation and Datalog.

;; We reuse our path example, but this time the nodes are terms constructed using the `mk` constructor,
;; We start by defining a new, union-able sort.
(sort Node)
;; We can then define a new constructor table for our sort.
(constructor mk (i64) Node)
;; Note: We could have equivalently written
;; ```
;; (datatype Node
;;     (mk i64))
;; ```
;; Internally, these become exactly the same thing!

(relation edge (Node Node))
(relation path (Node Node))

(rule ((edge x y))
      ((path x y)))
(rule ((path x y) (edge y z))
      ((path x z)))

(edge (mk 1) (mk 2))
(edge (mk 2) (mk 3))
(edge (mk 3) (mk 1))
(edge (mk 5) (mk 6))

;; Because we defined our nodes using a `sort`, we can "union" two nodes.
;; This makes them indistinguishable to rules in `egglog`.
(union (mk 3) (mk 5))

;; `union` is a new keyword here, but it is our old friend: `rewrite`s are implemented as rules whose
;; actions are `union`s. For instance, `(rewrite (Add a b) (Add b a))` is lowered to the following
;; rule:
;; ```
;; (rule ((= e (Add x y)))
;;       ((union e (Add y x))))
;; ```

(run-schedule (saturate (run)))

(check (edge (mk 3) (mk 6)))
(check (path (mk 1) (mk 6)))

;; We can also give a new meaning to equivalence by adding the following rule.
(rule ((path x y)
       (path y x))
      ((union x y)))
;; Now, we can tell if `a` and `b` are in the same connected component by checking
;; `(check (= (mk a) (mk b)))`.
;; In other words, this rule says that if there is a path from `x` to `y` and from `y` to `x`, then 
;; `x` and `y` are equivalent.
(run-schedule (saturate (run)))
(check (= (mk 1) (mk 2))
       (= (mk 1) (mk 3))
       (= (mk 2) (mk 3)))


;; **Exercises:**
;;
;; 1. In our lesson 1, it is tedious to write associativity and commutativity (AC) rules for
;;    every AC operators (e.g., Add, Mul, ...). One way to save us from this repetitive work
;;    is to parameterize over the operators.
;;    Rewrite this program so that instead of `Mul` and `Add`, `Expr` has a `Bop` operator
;;    that takes an operator kind and two operands.
;;        TODO: shouldn't this be an exercise in Section 1?
;; 2. One of the rewrite rules that we cannot make a `birewrite` in lesson 1 is the rule
;;    `(rewrite (Add x (Num 0)) x)`. This is because it is not clear what `x` is bound to 
;;    in the inverse rule, `(rewrite x (Add x (Num 0)))`. Therefore, defining this rule in egglog
;;    causes an error. One way to fix this is to introduce a "universe" relation, which contains
;;    every term in the e-graph. So we can write our rules as follows:
;;
;;     ```
;;     (rule ((universe x))
;;           ((union x (Add x (Num 0)))))
;;     ```
;;
;;     Please define such a `universe` relation so that the above rule works.
;;
;;     Side Note: The above rule can also be written using the shorthand `rewrite` with a `:when` 
;;     condition: `(rewrite x (Add x (Num 0)) :when ((universe x)))`, and similarly the birewrite
;;     rule `(birewrite (Add x (Num 0)) x :when ((universe x)))`, which introduces a bit of 
;;     overhead for the forward direction, but is more concise.



