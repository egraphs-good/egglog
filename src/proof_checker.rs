//! Proof checker for egglog proofs
//!
//! This module provides a proof checker that validates proofs generated by egglog.
//! The checker ensures that proof objects correctly justify the equality or term
//! existence claims they make.
//!
//! ## Proof Constructors
//!
//! The proof system supports the following proof constructors:
//!
//! ### PRule
//! Proves a term exists or two terms are equal by applying a rewrite rule.
//! Requires: rule name, variable substitution, and proofs of all premises.
//!
//! ### PCong
//! Proves that if two terms have equal arguments, the function applications are equal.
//! This is the congruence closure principle.
//!
//! ### PRefl, PSym, PTrans
//! Standard equality axioms: reflexivity, symmetry, and transitivity.
//!
//! ### PFiat (Axiom Proofs)
//! **Use case**: User-defined globals and base values inserted into the database.
//!
//! PFiat proofs are axiomatic - they assert a term exists or an equality holds
//! without providing justification. They should **only** be used for:
//! - User-defined global constants: `(let x (Const 42))`
//! - Base values inserted directly into the database
//!
//! **Current implementation note**: User-defined globals via `(let x expr)` currently
//! generate `PRule` proofs (with rule name `"eval_actions"`), but they are intended
//! to use `PFiat` proofs. This will be fixed in a future update.
//!
//! PFiat proofs should **NOT** be used for:
//! - Primitive operations (e.g., `+`, `-`, `*`)
//! - User-defined rewrite rules
//! - Congruence-derived equalities
//!
//! The checker accepts PFiat proofs as valid without further verification,
//! so they represent trusted axioms in the proof system.
//!
//! TODO make this test run and verify the proof:
//! ## Example
//! ```rust,no_run
//! use egglog::*;
//!
//! // Create an egraph with proofs enabled
//! let mut egraph = EGraph::with_proofs();
//!
//! // User-defined global - should generate a PFiat proof (currently PRule)
//! egraph.parse_and_run_program(None,
//!     "(datatype Math (Num i64))\n
//!      (let x (Num 42))"
//! ).unwrap();
//!
//! // Get the value for x
//! let x_val = egraph.eval_expr(&expr!("x")).unwrap();
//!
//! // Explain why x exists - should show PFiat proof (currently shows PRule)
//! let mut store = ProofStore::default();
//! let proof = egraph.explain_term(x_val, &mut store).unwrap();
//! ```

use crate::{
    ProofStore, TypeInfo,
    ast::{Command, GenericExpr, GenericFact, GenericRule},
    proof_type_inference::TypeInferenceContext,
    util::HashMap,
    util::HashSet,
};
use egglog_bridge::{
    proof_format::{EqProof, EqProofId, Premise, RuleVarBinding, TermProof, TermProofId},
    termdag::{Term, TermId},
};

/// Represents a proposition that can be proven
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub enum Proposition {
    /// A term is well-formed (exists in the e-graph)
    TermOk(TermId),
    /// Two terms are equal
    TermsEq(TermId, TermId),
}

/// Errors that can occur during proof checking
#[derive(Debug, Clone)]
pub enum ProofCheckError {
    /// The proof is invalid
    InvalidProof(String),
    /// Rule not found in program
    RuleNotFound(String),
    /// Substitution error
    SubstitutionError(String),
    /// Type mismatch
    TypeMismatch(String),
    /// Invalid premise
    InvalidPremise(String),
    /// Term not found
    TermNotFound,
    /// Invalid projection
    InvalidProjection,
    /// Transitivity error
    TransitivityError,
    /// Other error
    Other(String),
}

impl std::fmt::Display for ProofCheckError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProofCheckError::InvalidProof(s) => write!(f, "Invalid proof: {}", s),
            ProofCheckError::RuleNotFound(s) => write!(f, "Rule not found: {}", s),
            ProofCheckError::SubstitutionError(s) => write!(f, "Substitution error: {}", s),
            ProofCheckError::TypeMismatch(s) => write!(f, "Type mismatch: {}", s),
            ProofCheckError::InvalidPremise(s) => write!(f, "Invalid premise: {}", s),
            ProofCheckError::TermNotFound => write!(f, "Term not found"),
            ProofCheckError::InvalidProjection => write!(f, "Invalid projection"),
            ProofCheckError::TransitivityError => write!(f, "Transitivity error"),
            ProofCheckError::Other(s) => write!(f, "Error: {}", s),
        }
    }
}

impl std::error::Error for ProofCheckError {}

/// A proof checker that validates egglog proofs
pub struct ProofChecker<'a> {
    proof_store: &'a mut ProofStore,
    program: Vec<Command>,
    #[allow(dead_code)]
    global_terms: HashMap<String, TermId>,
    type_info: &'a TypeInfo,
}

impl<'a> ProofChecker<'a> {
    /// Create a new proof checker
    pub fn new(
        proof_store: &'a mut ProofStore,
        program: Vec<Command>,
        type_info: &'a TypeInfo,
    ) -> Self {
        // Extract globals from the program
        let mut global_terms = HashMap::default();

        // Look for Let commands that define globals
        for cmd in &program {
            if let Command::Action(crate::ast::Action::Let(_, name, _expr)) = cmd {
                // Track global definitions
                // Note: To fully validate PFiat proofs, we would need to evaluate
                // the expression _expr and store its TermId. However, this requires
                // access to the EGraph which we don't have here. For now, we record
                // the global name to validate that PFiat axioms refer to actual globals.
                // A placeholder TermId is used - in a complete implementation this would
                // be the actual evaluated TermId.
                global_terms.insert(name.clone(), TermId::from(0usize));
            }
        }

        ProofChecker {
            proof_store,
            program,
            global_terms,
            type_info,
        }
    }

    /// Apply a substitution to an expression, replacing variables with terms
    /// Get all propositions that a rule can produce given a substitution and premises
    fn rule_propositions(
        &mut self,
        rule: &GenericRule<String, String>,
        subst: &[RuleVarBinding],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        // Build a substitution map from variable names to TermIds
        let mut var_map: HashMap<String, TermId> = HashMap::default();
        for binding in subst {
            var_map.insert(binding.name.to_string(), binding.term);
        }

        // Process each action in the head to see what propositions it produces
        for action in rule.head.iter() {
            match action {
                crate::ast::Action::Expr(_, expr) => {
                    // An Expr action produces a TermOk proposition
                    let constructed_term = self.construct_term_from_expr(expr, &var_map)?;
                    result.insert(Proposition::TermOk(constructed_term));
                }
                crate::ast::Action::Let(_, _name, expr) => {
                    // A Let binding produces a TermOk proposition
                    let constructed_term = self.construct_term_from_expr(expr, &var_map)?;
                    result.insert(Proposition::TermOk(constructed_term));
                }
                crate::ast::Action::Union(_, lhs, rhs) => {
                    // A Union produces an equality proposition
                    let lhs_term = self.construct_term_from_expr(lhs, &var_map)?;
                    let rhs_term = self.construct_term_from_expr(rhs, &var_map)?;
                    result.insert(Proposition::TermsEq(lhs_term, rhs_term));
                    // Union is symmetric
                    result.insert(Proposition::TermsEq(rhs_term, lhs_term));
                }
                crate::ast::Action::Set(_, func_name, args, rhs) => {
                    // A Set produces an equality proposition between the function call and rhs
                    // First construct the function call term
                    let arg_terms: Result<Vec<_>, _> = args
                        .iter()
                        .map(|arg| self.construct_term_from_expr(arg, &var_map))
                        .collect();
                    let arg_terms = arg_terms?;
                    let lhs_term = self.proof_store.make_app(func_name.clone(), arg_terms);
                    let rhs_term = self.construct_term_from_expr(rhs, &var_map)?;
                    result.insert(Proposition::TermsEq(lhs_term, rhs_term));
                    // Set is also symmetric
                    result.insert(Proposition::TermsEq(rhs_term, lhs_term));
                }
                _ => {
                    // Other action types (Panic, Change) don't produce propositions we check
                }
            }
        }

        Ok(result)
    }

    /// Check if a term is a valid PFiat axiom
    fn is_valid_pfiat_term(&self, term: TermId) -> bool {
        let termdag = self.proof_store.termdag();

        // Literals are always valid axioms
        if matches!(termdag.get(term), Term::Lit(_)) {
            return true;
        }

        // Check if it's a global variable defined via (let x expr)
        if let Term::App(name, args) = termdag.get(term) {
            // Global variables are 0-ary functions
            if args.is_empty() {
                for cmd in &self.program {
                    if let Command::Action(crate::ast::Action::Let(_, global_name, _)) = cmd {
                        if global_name == name {
                            // Found a matching global definition
                            return true;
                        }
                    }
                }
            }
        }

        // Other cases we can't validate without more context
        false
    }

    /// Check a term proof
    pub fn check_term_proof(
        &mut self,
        proof_id: TermProofId,
    ) -> Result<Proposition, ProofCheckError> {
        let proof = self
            .proof_store
            .term_proof(proof_id)
            .ok_or(ProofCheckError::TermNotFound)?
            .clone(); // Clone to avoid borrow issues

        match proof {
            TermProof::PRule {
                rule_name,
                subst,
                body_pfs,
                result,
            } => {
                // Check that:
                // 1. The rule exists and fires with the given substitution
                // 2. The rule's head, when instantiated with the substitution, produces the result
                let rule = self.find_rule(&rule_name)?.clone();
                self.check_rule_fires(&rule_name, &subst, &body_pfs)?;

                // Get all propositions the rule can produce
                let propositions = self.rule_propositions(&rule, &subst)?;

                // Check if the result term is in the set of propositions
                if !propositions.contains(&Proposition::TermOk(result)) {
                    return Err(ProofCheckError::InvalidProof(format!(
                        "Rule does not produce the expected term {:?}",
                        result
                    )));
                }

                Ok(Proposition::TermOk(result))
            }
            TermProof::PProj {
                pf_f_args_ok,
                arg_idx,
            } => {
                // Check that the parent term is valid and project to child
                let parent_prop = self.check_term_proof(pf_f_args_ok)?;
                match parent_prop {
                    Proposition::TermOk(term_id) => {
                        // Get the children of the term through ProofStore's termdag
                        let children = self.proof_store.get_term_children(term_id);
                        if arg_idx < children.len() {
                            Ok(Proposition::TermOk(children[arg_idx]))
                        } else {
                            Err(ProofCheckError::InvalidProjection)
                        }
                    }
                    _ => Err(ProofCheckError::TypeMismatch(
                        "Expected term proof".to_string(),
                    )),
                }
            }
            TermProof::PCong(cong_proof) => {
                // Check congruence proof:
                // 1. The original term exists
                // 2. All arguments have equality proofs
                // 3. The new term is constructed correctly with rewritten arguments

                // Check that the original term exists
                let parent_prop = self.check_term_proof(cong_proof.pf_f_args_ok)?;
                let old_term = match parent_prop {
                    Proposition::TermOk(term) => term,
                    _ => {
                        return Err(ProofCheckError::TypeMismatch(
                            "Expected term proof for congruence".to_string(),
                        ));
                    }
                };

                // Get the structure of the old term
                let (func_name, old_args) = match self.proof_store.termdag().get(old_term) {
                    Term::App(func, args) => (func.clone(), args.clone()),
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence proof requires function application".to_string(),
                        ));
                    }
                };

                // Check that we have the right number of equality proofs
                if cong_proof.pf_args_eq.len() != old_args.len() {
                    return Err(ProofCheckError::InvalidProof(
                        "Wrong number of argument proofs in congruence".to_string(),
                    ));
                }

                // Check all child equality proofs and collect new arguments
                let mut new_args = Vec::new();
                let old_args_cloned = old_args.clone();
                for (i, eq_pf) in cong_proof.pf_args_eq.iter().enumerate() {
                    let eq_prop = self.check_eq_proof(*eq_pf)?;
                    match eq_prop {
                        Proposition::TermsEq(lhs, rhs) => {
                            // Verify that lhs matches the original argument
                            if lhs != old_args_cloned[i] {
                                return Err(ProofCheckError::InvalidProof(format!(
                                    "Congruence argument {} mismatch",
                                    i
                                )));
                            }
                            new_args.push(rhs);
                        }
                        _ => {
                            return Err(ProofCheckError::TypeMismatch(
                                "Expected equality proof".to_string(),
                            ));
                        }
                    }
                }

                // Verify that the new term is constructed correctly
                // We can't modify the termdag to create the expected term, so we check structurally
                // The new term should have the same function name and the new arguments
                let new_term_structure = self.proof_store.termdag().get(cong_proof.new_term);
                match new_term_structure {
                    Term::App(new_func, actual_new_args) => {
                        if new_func != &func_name || actual_new_args != &new_args {
                            return Err(ProofCheckError::InvalidProof(
                                "Congruence new term doesn't match expected construction"
                                    .to_string(),
                            ));
                        }
                    }
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence new term should be a function application".to_string(),
                        ));
                    }
                }

                Ok(Proposition::TermOk(cong_proof.new_term))
            }
            TermProof::PFiat { desc: _, term } => {
                // PFiat should only be used for globals and base values
                // Check if this term corresponds to a known global
                // Since we store globals as placeholder TermIds, we cannot
                // fully validate the PFiat proof without evaluating the global expressions.
                //
                // In practice, PFiat proofs are used for:
                // - Primitive operations
                // - Base literals
                // - Global variables
                //
                // The proof is trusted to be correct as an axiom.
                // TODO: Complete PFiat validation by:
                // 1. Evaluating global expressions during initialization to get their actual TermIds
                // 2. Maintaining a bidirectional mapping between global names and term representations
                // 3. Validating that PFiat terms match the expected global values
                //
                // For now, we validate what we can:
                // - Literals are always valid axioms
                // - Global names that appear in Let commands are considered valid
                if self.is_valid_pfiat_term(term) {
                    return Ok(Proposition::TermOk(term));
                }
                // Accept as trusted axiom if we can't validate
                Ok(Proposition::TermOk(term))
            }
        }
    }

    /// Check an equality proof
    pub fn check_eq_proof(&mut self, proof_id: EqProofId) -> Result<Proposition, ProofCheckError> {
        let proof = self
            .proof_store
            .eq_proof(proof_id)
            .ok_or(ProofCheckError::TermNotFound)?
            .clone(); // Clone to avoid borrow issues

        match proof {
            EqProof::PRule {
                rule_name,
                subst,
                body_pfs,
                result_lhs,
                result_rhs,
            } => {
                // Check that:
                // 1. The rule exists and fires with the given substitution
                // 2. The rule's head, when instantiated with the substitution, produces the equality
                let rule = self.find_rule(&rule_name)?.clone();
                self.check_rule_fires(&rule_name, &subst, &body_pfs)?;

                // Get all propositions the rule can produce
                let propositions = self.rule_propositions(&rule, &subst)?;

                // Check if the equality is in the set of propositions
                let prop = Proposition::TermsEq(result_lhs, result_rhs);
                if !propositions.contains(&prop) {
                    // Also check the symmetric version
                    let prop_sym = Proposition::TermsEq(result_rhs, result_lhs);
                    if !propositions.contains(&prop_sym) {
                        return Err(ProofCheckError::InvalidProof(format!(
                            "Rule does not produce the expected equality {:?} = {:?}",
                            result_lhs, result_rhs
                        )));
                    }
                }

                Ok(Proposition::TermsEq(result_lhs, result_rhs))
            }
            EqProof::PRefl { t_ok_pf, t } => {
                // Check that the term is valid
                let prop = self.check_term_proof(t_ok_pf)?;
                match prop {
                    Proposition::TermOk(term) if term == t => Ok(Proposition::TermsEq(t, t)),
                    _ => Err(ProofCheckError::InvalidProof(
                        "Reflexivity proof term mismatch".to_string(),
                    )),
                }
            }
            EqProof::PSym { eq_pf } => {
                // Check symmetry
                let prop = self.check_eq_proof(eq_pf)?;
                match prop {
                    Proposition::TermsEq(a, b) => Ok(Proposition::TermsEq(b, a)),
                    _ => Err(ProofCheckError::TypeMismatch(
                        "Expected equality proof".to_string(),
                    )),
                }
            }
            EqProof::PTrans { pfxy, pfyz } => {
                // Check transitivity
                let prop_xy = self.check_eq_proof(pfxy)?;
                let prop_yz = self.check_eq_proof(pfyz)?;
                match (prop_xy, prop_yz) {
                    (Proposition::TermsEq(x, y1), Proposition::TermsEq(y2, z)) if y1 == y2 => {
                        Ok(Proposition::TermsEq(x, z))
                    }
                    _ => Err(ProofCheckError::TransitivityError),
                }
            }
            EqProof::PCong(cong_proof) => {
                // Check congruence for equality:
                // 1. The original term exists
                // 2. All arguments have equality proofs
                // 3. The new term is constructed correctly with rewritten arguments

                // Check that the original term exists
                let parent_prop = self.check_term_proof(cong_proof.pf_f_args_ok)?;
                let old_term = match parent_prop {
                    Proposition::TermOk(term) => term,
                    _ => {
                        return Err(ProofCheckError::TypeMismatch(
                            "Expected term proof for congruence".to_string(),
                        ));
                    }
                };

                // Verify old_term matches what's in the congruence proof
                if old_term != cong_proof.old_term {
                    return Err(ProofCheckError::InvalidProof(
                        "Congruence old term mismatch".to_string(),
                    ));
                }

                // Get the structure of the old term
                let (func_name, old_args) = match self.proof_store.termdag().get(old_term) {
                    Term::App(func, args) => (func.clone(), args.clone()),
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence proof requires function application".to_string(),
                        ));
                    }
                };

                // Check that we have the right number of equality proofs
                if cong_proof.pf_args_eq.len() != old_args.len() {
                    return Err(ProofCheckError::InvalidProof(
                        "Wrong number of argument proofs in congruence".to_string(),
                    ));
                }

                // Check all child equality proofs and collect new arguments
                let mut new_args = Vec::new();
                let old_args_cloned = old_args.clone();
                for (i, eq_pf) in cong_proof.pf_args_eq.iter().enumerate() {
                    let eq_prop = self.check_eq_proof(*eq_pf)?;
                    match eq_prop {
                        Proposition::TermsEq(lhs, rhs) => {
                            // Verify that lhs matches the original argument
                            if lhs != old_args_cloned[i] {
                                return Err(ProofCheckError::InvalidProof(format!(
                                    "Congruence argument {} mismatch",
                                    i
                                )));
                            }
                            new_args.push(rhs);
                        }
                        _ => {
                            return Err(ProofCheckError::TypeMismatch(
                                "Expected equality proof".to_string(),
                            ));
                        }
                    }
                }

                // Verify that the new term is constructed correctly
                // We can't modify the termdag to create the expected term, so we check structurally
                // The new term should have the same function name and the new arguments
                let new_term_structure = self.proof_store.termdag().get(cong_proof.new_term);
                match new_term_structure {
                    Term::App(new_func, actual_new_args) => {
                        if new_func != &func_name || actual_new_args != &new_args {
                            return Err(ProofCheckError::InvalidProof(
                                "Congruence new term doesn't match expected construction"
                                    .to_string(),
                            ));
                        }
                    }
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence new term should be a function application".to_string(),
                        ));
                    }
                }

                Ok(Proposition::TermsEq(
                    cong_proof.old_term,
                    cong_proof.new_term,
                ))
            }
            EqProof::PFiat { desc: _, lhs, rhs } => {
                // PFiat for equalities should only be used for:
                // 1. Primitive operations (which we validate)
                // 2. User-defined equalities from globals

                // First check if this is a primitive operation we can validate
                if let Some(validation_result) = self.check_primitive_validation(lhs, rhs) {
                    if !validation_result {
                        return Err(ProofCheckError::InvalidProof(
                            "Primitive validation failed: incorrect computation".to_string(),
                        ));
                    }
                    // Primitive validated successfully
                    return Ok(Proposition::TermsEq(lhs, rhs));
                }

                // If not a primitive, this should be from a user-defined global
                // Since we can't easily map terms back to global names,
                // we accept this as a trusted axiom.
                // A complete implementation would maintain a bidirectional mapping
                // between global names and their term representations.
                Ok(Proposition::TermsEq(lhs, rhs))
            }
        }
    }

    /// Check if a primitive computation is valid
    /// Returns Some(true) if valid, Some(false) if invalid, None if not a primitive/can't check
    fn check_primitive_validation(&self, lhs: TermId, rhs: TermId) -> Option<bool> {
        // Get termdag and check if this is a validatable primitive
        let termdag = self.proof_store.termdag();

        // Check if lhs is a primitive operation we can validate
        if let Term::App(func, args) = termdag.get(lhs) {
            // Look up all overloaded primitives with this name
            if let Some(prims) = self.type_info.get_prims(func) {
                // Create a type inference context to identify the correct primitive
                let mut type_ctx =
                    TypeInferenceContext::new(termdag, self.type_info, &self.program);

                // Try to find the specific primitive that matches
                if let Some(prim_idx) = type_ctx.find_matching_primitive(func, args) {
                    // Found the specific primitive - use its validator
                    if let Some(prim) = prims.get(prim_idx) {
                        if let Some(validator) = &prim.validator {
                            if let Some(computed_lit) = validator(termdag, lhs) {
                                // Check if the result matches
                                if let Term::Lit(actual_lit) = termdag.get(rhs) {
                                    return Some(&computed_lit == actual_lit);
                                } else {
                                    return Some(false);
                                }
                            } else {
                                // The validator couldn't compute (e.g., non-constant arguments)
                                // This doesn't mean computation failed, just that it can't be validated
                                return None;
                            }
                        } else {
                            // No validator for this specific primitive
                            return None;
                        }
                    }
                } else {
                    // Couldn't determine the specific primitive from types
                    // Fall back to letting validators self-identify
                    for prim in prims {
                        if let Some(validator) = &prim.validator {
                            if let Some(computed_lit) = validator(termdag, lhs) {
                                if let Term::Lit(actual_lit) = termdag.get(rhs) {
                                    return Some(&computed_lit == actual_lit);
                                } else {
                                    return Some(false);
                                }
                            }
                        }
                    }
                }

                // If we have validators but none matched, this is an error
                if prims.iter().any(|p| p.validator.is_some()) {
                    return Some(false);
                }
            }
        }

        // Not a primitive we can validate
        None
    }

    /// Check that a rule fires with the given substitution and premises
    fn check_rule_fires(
        &mut self,
        rule_name: &str,
        _subst: &[RuleVarBinding],
        body_pfs: &[Premise],
    ) -> Result<(), ProofCheckError> {
        // Find the rule in the program
        let rule = self.find_rule(rule_name)?.clone();

        // Verify that we have the right number of premises
        if body_pfs.len() != rule.body.len() {
            return Err(ProofCheckError::InvalidProof(format!(
                "Rule '{}' expects {} body facts, but proof provides {} premises",
                rule_name,
                rule.body.len(),
                body_pfs.len()
            )));
        }

        // The actual verification that premises match the rule body is lightweight
        // Most validation happens in rule_propositions which verifies the rule output

        // Check each premise
        for (i, premise) in body_pfs.iter().enumerate() {
            let body_fact = &rule.body[i];
            match premise {
                Premise::TermOk(term_pf) => {
                    let prop = self.check_term_proof(*term_pf)?;
                    // Verify this corresponds to a fact in the rule body
                    if let Proposition::TermOk(_term) = prop {
                        // Check that this is the right kind of premise for this body fact
                        match body_fact {
                            GenericFact::Fact(_expr) => {
                                // This is correct - a Fact in the body should have a TermOk proof
                                // Ideally we would verify that 'term' matches the instantiation
                                // of 'expr' with 'subst', but that requires term construction
                            }
                            GenericFact::Eq(_, _, _) => {
                                return Err(ProofCheckError::InvalidPremise(format!(
                                    "Premise {} is a term proof but body expects equality",
                                    i
                                )));
                            }
                        }
                    } else {
                        return Err(ProofCheckError::InvalidPremise(format!(
                            "Premise {} is not a valid term proof",
                            i
                        )));
                    }
                }
                Premise::Eq(eq_pf) => {
                    let prop = self.check_eq_proof(*eq_pf)?;
                    // Verify this corresponds to an equality in the rule body
                    if let Proposition::TermsEq(_lhs, _rhs) = prop {
                        // Check that this is the right kind of premise for this body fact
                        match body_fact {
                            GenericFact::Eq(_, _e1, _e2) => {
                                // This is correct - an Eq in the body should have an equality proof
                                // Ideally we would verify that lhs/rhs match the instantiation
                                // of e1/e2 with 'subst', but that requires term construction
                            }
                            GenericFact::Fact(_) => {
                                return Err(ProofCheckError::InvalidPremise(format!(
                                    "Premise {} is an equality proof but body expects term",
                                    i
                                )));
                            }
                        }
                    } else {
                        return Err(ProofCheckError::InvalidPremise(format!(
                            "Premise {} is not a valid equality proof",
                            i
                        )));
                    }
                }
            }
        }

        // The actual verification that the rule's head produces the claimed result
        // is done in rule_propositions which checks against all possible propositions

        Ok(())
    }

    /// Collect all variable names from a fact
    /// Find a rule by name in the program
    fn find_rule(&self, rule_name: &str) -> Result<&GenericRule<String, String>, ProofCheckError> {
        for cmd in &self.program {
            if let Command::Rule { rule } = cmd {
                if rule.name == rule_name {
                    return Ok(rule);
                }
            }
        }
        Err(ProofCheckError::RuleNotFound(rule_name.to_string()))
    }

    /// Construct a term from an expression with variable substitution
    fn construct_term_from_expr(
        &mut self,
        expr: &GenericExpr<String, String>,
        var_map: &HashMap<String, TermId>,
    ) -> Result<TermId, ProofCheckError> {
        match expr {
            GenericExpr::Var(_, name) => var_map.get(name).cloned().ok_or_else(|| {
                ProofCheckError::SubstitutionError(format!(
                    "Variable '{}' not found in substitution",
                    name
                ))
            }),
            GenericExpr::Lit(_, lit) => Ok(self.proof_store.make_lit(lit.clone())),
            GenericExpr::Call(_, func, args) => {
                let arg_terms: Result<Vec<_>, _> = args
                    .iter()
                    .map(|arg| self.construct_term_from_expr(arg, var_map))
                    .collect();
                let arg_terms = arg_terms?;
                Ok(self.proof_store.make_app(func.clone(), arg_terms))
            }
        }
    }
}
