//! Proof checker for egglog proofs
//!
//! This module provides a proof checker that validates proofs generated by egglog.
//! The checker ensures that proof objects correctly justify the equality or term
//! existence claims they make.
//!
//! ## Example
//! ```
//! use egglog::*;
//! use egglog::prelude::*;
//!
//! // Create an egraph with proofs enabled
//! let mut egraph = EGraph::with_proofs();
//!
//! // Define a simple datatype and global
//! egraph.parse_and_run_program(None,
//!     "(datatype Math (Num i64))\n
//!      (let x (Num 42))"
//! ).unwrap();
//!
//! // Get the value for x
//! let x_expr = egglog::ast::ResolvedExpr::Var(span!(), "x".to_string());
//! let (_, x_val) = egraph.eval_expr(&x_expr).unwrap();
//!
//! // Get the proof store and explain why x exists
//! let mut store = ProofStore::default();
//! let proof_id = egraph.explain_term(x_val, &mut store).unwrap();
//!
//! let mut output = Vec::new();
//! store.print_term_proof(proof_id, &mut output).unwrap();
//! ```

use crate::ast::{ResolvedAction, ResolvedCommand};
use crate::{
    ProofStore, TypeInfo,
    ast::{ResolvedExpr, ResolvedFact, ResolvedRule},
    util::HashMap,
    util::HashSet,
};
use crate::{ResolvedCall, SpecializedPrimitive};
use egglog_ast::span::Span;
use egglog_bridge::{
    proof_format::{EqProof, EqProofId, Premise, RuleVarBinding, TermProof, TermProofId},
    termdag::{Term, TermId},
};

/// Represents a proposition that can be proven
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub enum Proposition {
    /// A term is well-formed (exists in the e-graph)
    TermOk(TermId),
    /// Two terms are equal
    TermsEq(TermId, TermId),
}

/// Errors that can occur during proof checking
#[derive(Debug, Clone)]
pub enum ProofCheckError {
    /// The proof is invalid
    InvalidProof(String),
    /// Rule not found in program
    RuleNotFound(String),
    /// Substitution error
    SubstitutionError(String),
    /// Type mismatch
    TypeMismatch(String),
    /// Invalid premise
    InvalidPremise(String),
    /// Term not found
    TermNotFound,
    /// Invalid projection
    InvalidProjection,
    /// Transitivity error
    TransitivityError,
    /// Other error
    Other(String),
}

impl std::fmt::Display for ProofCheckError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProofCheckError::InvalidProof(s) => write!(f, "Invalid proof: {}", s),
            ProofCheckError::RuleNotFound(s) => write!(f, "Rule not found: {}", s),
            ProofCheckError::SubstitutionError(s) => write!(f, "Substitution error: {}", s),
            ProofCheckError::TypeMismatch(s) => write!(f, "Type mismatch: {}", s),
            ProofCheckError::InvalidPremise(s) => write!(f, "Invalid premise: {}", s),
            ProofCheckError::TermNotFound => write!(f, "Term not found"),
            ProofCheckError::InvalidProjection => write!(f, "Invalid projection"),
            ProofCheckError::TransitivityError => write!(f, "Transitivity error"),
            ProofCheckError::Other(s) => write!(f, "Error: {}", s),
        }
    }
}

impl std::error::Error for ProofCheckError {}

/// A proof checker that validates egglog proofs
pub struct ProofChecker<'a> {
    proof_store: &'a mut ProofStore,
    program: &'a Vec<ResolvedCommand>,
    /// Set of equalities established by global union actions
    /// Each entry is a pair (lhs, rhs) that was unified
    global_unions: HashSet<(TermId, TermId)>,
    type_info: &'a TypeInfo,
}

impl<'a> ProofChecker<'a> {
    /// Create a new proof checker
    pub fn new(
        proof_store: &'a mut ProofStore,
        program: &'a Vec<ResolvedCommand>,
        type_info: &'a TypeInfo,
    ) -> Result<Self, ProofCheckError> {
        let mut checker = ProofChecker {
            proof_store,
            program,
            global_unions: HashSet::default(),
            type_info,
        };

        // Process globals to get their actual TermIds
        checker.process_globals()?;
        Ok(checker)
    }

    /// Process global definitions and evaluate them to produce [`TermId`]s
    fn process_globals(&mut self) -> Result<(), ProofCheckError> {
        // Process globals in order, building up the mapping
        let program_cmds = self.program.clone();

        for cmd in &program_cmds {
            if let ResolvedCommand::Action(action) = cmd {
                match action {
                    ResolvedAction::Union(_, lhs, rhs) => {
                        // Track global union actions
                        if let (Ok(lhs_term), Ok(rhs_term)) = (
                            self.evaluate_expr(lhs, &HashMap::default(), &mut HashSet::default()),
                            self.evaluate_expr(rhs, &HashMap::default(), &mut HashSet::default()),
                        ) {
                            // Store both directions of the equality
                            self.global_unions.insert((lhs_term, rhs_term));
                            self.global_unions.insert((rhs_term, lhs_term));
                            // Store reflexive equalities as well
                            self.global_unions.insert((lhs_term, lhs_term));
                            self.global_unions.insert((rhs_term, rhs_term));
                        }
                    }
                    ResolvedAction::Set(span, func, args, rhs) => {
                        let mut args_extended = args.clone();
                        args_extended.push(rhs.clone());
                        let term_created = self.evaluate_expr(
                            &ResolvedExpr::Call(span.clone(), func.clone(), args_extended),
                            &HashMap::default(),
                            &mut HashSet::default(),
                        )?;
                        self.global_unions
                            .insert((term_created.clone(), term_created));
                    }
                    _ => {}
                }
            }
        }

        Ok(())
    }

    /// Apply a substitution to an expression, replacing variables with terms
    /// Unified expression evaluation that handles both variables and globals
    /// The environment can contain both substituted variables and global definitions
    /// This is used by queries, actions, and global evaluation  
    fn evaluate_expr(
        &mut self,
        expr: &ResolvedExpr,
        env: &HashMap<String, TermId>,
        visited: &mut HashSet<TermId>,
    ) -> Result<TermId, ProofCheckError> {
        match expr {
            ResolvedExpr::Var(_, name) => {
                let res = env.get(name.name()).cloned().ok_or_else(|| {
                    ProofCheckError::SubstitutionError(format!(
                        "Variable or global '{}' not found in environment",
                        name
                    ))
                })?;

                visited.insert(res);
                Ok(res)
            }
            ResolvedExpr::Lit(_, lit) => Ok(self.proof_store.make_lit(lit.clone())),
            ResolvedExpr::Call(_, func, args) => {
                let mut arg_terms = vec![];
                for arg in args {
                    let arg_term = self.evaluate_expr(arg, env, visited)?;
                    arg_terms.push(arg_term);
                }

                match func {
                    ResolvedCall::Func(func_type) => Ok(self
                        .proof_store
                        .make_app(func_type.name.clone(), arg_terms.clone())),
                    ResolvedCall::Primitive(specialized_primitive) => {
                        self.evaluate_primitive(specialized_primitive, &arg_terms)
                    }
                }
            }
        }
    }

    fn evaluate_primitive(
        &mut self,
        prim: &SpecializedPrimitive,
        arg_terms: &[TermId],
    ) -> Result<TermId, ProofCheckError> {
        // Get the termdag for evaluation
        let termdag = self.proof_store.termdag();

        // Get the validator for this primitive
        // TODO find the validator in type_info
        todo!("");
    }

    /// Infer the type of a term from the termdag.
    /// Get all propositions that a rule can produce given a substitution and premises
    fn rule_propositions(
        &mut self,
        rule: &ResolvedRule,
        subst: &[RuleVarBinding],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        // Build a substitution map from variable names to TermIds
        let mut var_map: HashMap<String, TermId> = HashMap::default();
        for binding in subst {
            var_map.insert(binding.name.to_string(), binding.term);
        }

        // Process each action in the head to see what propositions it produces
        for action in rule.head.iter() {
            let props = self.get_propositions_from_action(action, &var_map)?;
            result.extend(props);
        }

        Ok(result)
    }

    /// Check if a term is a valid PFiat axiom
    fn is_valid_pfiat_term(&self, term: TermId) -> bool {
        let termdag = self.proof_store.termdag();

        // Literals are always valid axioms
        matches!(termdag.get(term), Term::Lit(_)) || self.global_unions.contains(&(term, term))
    }

    /// Check if a function is a primitive operation
    /// Check a term proof
    pub fn check_term_proof(
        &mut self,
        proof_id: TermProofId,
    ) -> Result<Proposition, ProofCheckError> {
        let proof = self
            .proof_store
            .term_proof(proof_id)
            .ok_or(ProofCheckError::TermNotFound)?
            .clone(); // Clone to avoid borrow issues

        match proof {
            TermProof::PRule {
                rule_name,
                subst,
                body_pfs,
                result,
            } => {
                // Check that:
                // 1. The rule exists and fires with the given substitution
                // 2. The rule's head, when instantiated with the substitution, produces the result
                let rule = self.find_rule(&rule_name)?.clone();
                self.check_rule_fires(&rule_name, &subst, &body_pfs)?;

                // Get all propositions the rule can produce
                let propositions = self.rule_propositions(&rule, &subst)?;

                // Check if the result term is in the set of propositions
                if !propositions.contains(&Proposition::TermOk(result)) {
                    return Err(ProofCheckError::InvalidProof(format!(
                        "Rule does not produce the expected term {:?}",
                        result
                    )));
                }

                Ok(Proposition::TermOk(result))
            }
            TermProof::PProj {
                pf_f_args_ok,
                arg_idx,
            } => {
                // Check that the parent term is valid and project to child
                let parent_prop = self.check_term_proof(pf_f_args_ok)?;
                match parent_prop {
                    Proposition::TermOk(term_id) => {
                        // Get the children of the term through ProofStore's termdag
                        let children = self.proof_store.get_term_children(term_id);
                        if arg_idx < children.len() {
                            Ok(Proposition::TermOk(children[arg_idx]))
                        } else {
                            Err(ProofCheckError::InvalidProjection)
                        }
                    }
                    _ => Err(ProofCheckError::TypeMismatch(
                        "Expected term proof".to_string(),
                    )),
                }
            }
            TermProof::PCong(cong_proof) => {
                // Check congruence proof:
                // 1. The original term exists
                // 2. All arguments have equality proofs
                // 3. The new term is constructed correctly with rewritten arguments

                // Check that the original term exists
                let parent_prop = self.check_term_proof(cong_proof.pf_f_args_ok)?;
                let old_term = match parent_prop {
                    Proposition::TermOk(term) => term,
                    _ => {
                        return Err(ProofCheckError::TypeMismatch(
                            "Expected term proof for congruence".to_string(),
                        ));
                    }
                };

                // Get the structure of the old term
                let (func_name, old_args) = match self.proof_store.termdag().get(old_term) {
                    Term::App(func, args) => (func.clone(), args.clone()),
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence proof requires function application".to_string(),
                        ));
                    }
                };

                // Check that we have the right number of equality proofs
                if cong_proof.pf_args_eq.len() != old_args.len() {
                    return Err(ProofCheckError::InvalidProof(
                        "Wrong number of argument proofs in congruence".to_string(),
                    ));
                }

                // Check all child equality proofs and collect new arguments
                let mut new_args = Vec::new();
                let old_args_cloned = old_args.clone();
                for (i, eq_pf) in cong_proof.pf_args_eq.iter().enumerate() {
                    let eq_prop = self.check_eq_proof(*eq_pf)?;
                    match eq_prop {
                        Proposition::TermsEq(lhs, rhs) => {
                            // Verify that lhs matches the original argument
                            if lhs != old_args_cloned[i] {
                                return Err(ProofCheckError::InvalidProof(format!(
                                    "Congruence argument {} mismatch",
                                    i
                                )));
                            }
                            new_args.push(rhs);
                        }
                        _ => {
                            return Err(ProofCheckError::TypeMismatch(
                                "Expected equality proof".to_string(),
                            ));
                        }
                    }
                }

                // Verify that the new term is constructed correctly
                // Construct the expected new term directly and verify it matches
                let expected_new_term = self.proof_store.make_app(func_name, new_args.clone());

                // Verify that the claimed new term matches what we constructed
                if cong_proof.new_term != expected_new_term {
                    // Get detailed information for error reporting
                    let actual_structure = self.proof_store.termdag().get(cong_proof.new_term);
                    let expected_structure = self.proof_store.termdag().get(expected_new_term);
                    return Err(ProofCheckError::InvalidProof(format!(
                        "Congruence new term mismatch. Expected term {:?} (structure: {:?}) but got term {:?} (structure: {:?})",
                        expected_new_term,
                        expected_structure,
                        cong_proof.new_term,
                        actual_structure
                    )));
                }

                Ok(Proposition::TermOk(cong_proof.new_term))
            }
            TermProof::PFiat { desc: _, term } => {
                // PFiat should only be used for terms declared globally or literals.
                if self.is_valid_pfiat_term(term) {
                    return Ok(Proposition::TermOk(term));
                }

                let term_str = format!("{:?}", self.proof_store.termdag().get(term));
                Err(ProofCheckError::InvalidProof(format!(
                    "PFiat proof for term '{}' does not correspond to a known global or literal.",
                    term_str
                )))
            }
        }
    }

    /// Check an equality proof
    pub fn check_eq_proof(&mut self, proof_id: EqProofId) -> Result<Proposition, ProofCheckError> {
        let proof = self
            .proof_store
            .eq_proof(proof_id)
            .ok_or(ProofCheckError::TermNotFound)?
            .clone(); // Clone to avoid borrow issues

        match proof {
            EqProof::PRule {
                rule_name,
                subst,
                body_pfs,
                result_lhs,
                result_rhs,
            } => {
                // Check that:
                // 1. The rule exists and fires with the given substitution
                // 2. The rule's head, when instantiated with the substitution, produces the equality
                let rule = self.find_rule(&rule_name)?.clone();
                self.check_rule_fires(&rule_name, &subst, &body_pfs)?;

                // Get all propositions the rule can produce
                let propositions = self.rule_propositions(&rule, &subst)?;

                // Check if the equality is in the set of propositions
                let prop = Proposition::TermsEq(result_lhs, result_rhs);
                if !propositions.contains(&prop) {
                    // Also check the symmetric version
                    let prop_sym = Proposition::TermsEq(result_rhs, result_lhs);
                    if !propositions.contains(&prop_sym) {
                        return Err(ProofCheckError::InvalidProof(format!(
                            "Rule does not produce the expected equality {:?} = {:?}",
                            result_lhs, result_rhs
                        )));
                    }
                }

                Ok(Proposition::TermsEq(result_lhs, result_rhs))
            }
            EqProof::PRefl { t_ok_pf, t } => {
                // Check that the term is valid
                let prop = self.check_term_proof(t_ok_pf)?;
                match prop {
                    Proposition::TermOk(term) if term == t => Ok(Proposition::TermsEq(t, t)),
                    _ => Err(ProofCheckError::InvalidProof(
                        "Reflexivity proof term mismatch".to_string(),
                    )),
                }
            }
            EqProof::PSym { eq_pf } => {
                // Check symmetry
                let prop = self.check_eq_proof(eq_pf)?;
                match prop {
                    Proposition::TermsEq(a, b) => Ok(Proposition::TermsEq(b, a)),
                    _ => Err(ProofCheckError::TypeMismatch(
                        "Expected equality proof".to_string(),
                    )),
                }
            }
            EqProof::PTrans { pfxy, pfyz } => {
                // Check transitivity
                let prop_xy = self.check_eq_proof(pfxy)?;
                let prop_yz = self.check_eq_proof(pfyz)?;
                match (prop_xy, prop_yz) {
                    (Proposition::TermsEq(x, y1), Proposition::TermsEq(y2, z)) if y1 == y2 => {
                        Ok(Proposition::TermsEq(x, z))
                    }
                    _ => Err(ProofCheckError::TransitivityError),
                }
            }
            EqProof::PCong(cong_proof) => {
                // Check congruence for equality:
                // 1. The original term exists
                // 2. All arguments have equality proofs
                // 3. The new term is constructed correctly with rewritten arguments

                // Check that the original term exists
                let parent_prop = self.check_term_proof(cong_proof.pf_f_args_ok)?;
                let old_term = match parent_prop {
                    Proposition::TermOk(term) => term,
                    _ => {
                        return Err(ProofCheckError::TypeMismatch(
                            "Expected term proof for congruence".to_string(),
                        ));
                    }
                };

                // Verify old_term matches what's in the congruence proof
                if old_term != cong_proof.old_term {
                    return Err(ProofCheckError::InvalidProof(
                        "Congruence old term mismatch".to_string(),
                    ));
                }

                // Get the structure of the old term
                let (func_name, old_args) = match self.proof_store.termdag().get(old_term) {
                    Term::App(func, args) => (func.clone(), args.clone()),
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence proof requires function application".to_string(),
                        ));
                    }
                };

                // Check that we have the right number of equality proofs
                if cong_proof.pf_args_eq.len() != old_args.len() {
                    return Err(ProofCheckError::InvalidProof(
                        "Wrong number of argument proofs in congruence".to_string(),
                    ));
                }

                // Check all child equality proofs and collect new arguments
                let mut new_args = Vec::new();
                let old_args_cloned = old_args.clone();
                for (i, eq_pf) in cong_proof.pf_args_eq.iter().enumerate() {
                    let eq_prop = self.check_eq_proof(*eq_pf)?;
                    match eq_prop {
                        Proposition::TermsEq(lhs, rhs) => {
                            // Verify that lhs matches the original argument
                            if lhs != old_args_cloned[i] {
                                return Err(ProofCheckError::InvalidProof(format!(
                                    "Congruence argument {} mismatch",
                                    i
                                )));
                            }
                            new_args.push(rhs);
                        }
                        _ => {
                            return Err(ProofCheckError::TypeMismatch(
                                "Expected equality proof".to_string(),
                            ));
                        }
                    }
                }

                // Verify that the new term is constructed correctly
                // Verify that the new term is constructed correctly by checking:
                // 1. The function name is the same
                // 2. The arguments match the rewritten arguments from the equality proofs
                let new_term_structure = self.proof_store.termdag().get(cong_proof.new_term);
                match new_term_structure {
                    Term::App(new_func, actual_new_args) => {
                        if new_func != &func_name || actual_new_args != &new_args {
                            return Err(ProofCheckError::InvalidProof(format!(
                                "Congruence new term doesn't match expected construction. Expected {}({:?}) but got {}({:?})",
                                func_name, new_args, new_func, actual_new_args
                            )));
                        }
                    }
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence new term should be a function application".to_string(),
                        ));
                    }
                }

                Ok(Proposition::TermsEq(
                    cong_proof.old_term,
                    cong_proof.new_term,
                ))
            }
            EqProof::PFiat { desc: _, lhs, rhs } => {
                // PFiat equalities should only be used for global union actions
                // Check if this equality was established by a global union action
                if self.global_unions.contains(&(lhs, rhs)) {
                    Ok(Proposition::TermsEq(lhs, rhs))
                } else {
                    Err(ProofCheckError::InvalidProof(format!(
                        "PFiat equality ({:?}, {:?}) does not correspond to a global union action",
                        lhs, rhs
                    )))
                }
            }
        }
    }

    /// Check that a rule fires with the given substitution and premises
    fn check_rule_fires(
        &mut self,
        rule_name: &str,
        subst: &[RuleVarBinding],
        body_pfs: &[Premise],
    ) -> Result<(), ProofCheckError> {
        // Check for duplicate variable bindings
        let mut seen_vars = HashSet::default();
        for binding in subst {
            if !seen_vars.insert(&binding.name) {
                return Err(ProofCheckError::InvalidProof(format!(
                    "Duplicate variable binding for '{}' in rule '{}'",
                    binding.name, rule_name
                )));
            }
        }

        // Find the rule in the program
        let rule = self.find_rule(rule_name)?.clone();

        // Rules with empty bodies (no query) are axioms that require no premises to fire
        // They can produce terms/equalities unconditionally
        if rule.body.is_empty() {
            // Empty body = no premises required, this is valid
            if !body_pfs.is_empty() {
                return Err(ProofCheckError::InvalidProof(
                    "Empty body rule should have no premises".to_string(),
                ));
            }
            return Ok(());
        }

        // Get the expected propositions by applying substitution to the rule's query
        let expected_props = self.get_query_propositions(&rule, subst)?;

        // Get the actual propositions from the proof premises
        let actual_props = self.get_premise_propositions(body_pfs)?;

        // Check that the propositions match exactly
        if expected_props != actual_props {
            return Err(ProofCheckError::InvalidProof(format!(
                "Rule '{}' premises don't match expected propositions. Expected: {:?}, Got: {:?}",
                rule_name, expected_props, actual_props
            )));
        }

        Ok(())
    }

    /// Collect all variable names from a fact
    /// Find a rule by name in the program
    fn find_rule(&self, rule_name: &str) -> Result<&ResolvedRule, ProofCheckError> {
        for cmd in self.program {
            if let ResolvedCommand::Rule { rule } = cmd {
                if rule.name == rule_name {
                    return Ok(rule);
                }
            }
        }
        Err(ProofCheckError::RuleNotFound(rule_name.to_string()))
    }

    /// Construct a term from an expression with variable substitution
    fn construct_term_from_expr(
        &mut self,
        expr: &ResolvedExpr,
        var_map: &HashMap<String, TermId>,
    ) -> Result<TermId, ProofCheckError> {
        // Use the unified evaluation function
        self.evaluate_expr(expr, var_map, &mut HashSet::default())
    }

    /// Shared method to get propositions from expressions or facts
    /// This handles queries, globals, and actions uniformly including primitives
    fn get_propositions_from_fact(
        &mut self,
        fact: &ResolvedFact,
        var_map: &HashMap<String, TermId>,
    ) -> Result<Proposition, ProofCheckError> {
        match fact {
            ResolvedFact::Eq(_, lhs, rhs) => {
                let lhs_term = self.construct_term_from_expr(lhs, var_map)?;
                let rhs_term = self.construct_term_from_expr(rhs, var_map)?;
                Ok(Proposition::TermsEq(lhs_term, rhs_term))
            }
            ResolvedFact::Fact(expr) => {
                let term = self.construct_term_from_expr(expr, var_map)?;
                Ok(Proposition::TermOk(term))
            }
        }
    }

    /// Get propositions from an action (for rule heads)
    fn get_propositions_from_action(
        &mut self,
        action: &ResolvedAction,
        var_map: &HashMap<String, TermId>,
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut propositions = HashSet::default();

        match action {
            ResolvedAction::Let(_, _name, expr) => {
                // Let creates a term
                let mut subterms = HashSet::default();
                self.evaluate_expr(expr, var_map, &mut subterms)?;
                // Add all subexpression terms
                for term in subterms {
                    propositions.insert(Proposition::TermOk(term));
                }
            }
            ResolvedAction::Set(_, lhs, args, rhs) => {
                // Set creates an equality (f(args) = rhs)
                let app_expr = ResolvedExpr::Call(Span::Panic, lhs.clone(), args.clone());
                let mut subterms = HashSet::default();
                let lhs_term = self.evaluate_expr(&app_expr, var_map, &mut subterms)?;
                let rhs_term = self.evaluate_expr(rhs, var_map, &mut subterms)?;

                // Add all subexpression terms
                for term in subterms {
                    propositions.insert(Proposition::TermOk(term));
                }

                // Add the equality proposition
                propositions.insert(Proposition::TermsEq(lhs_term, rhs_term));
            }
            ResolvedAction::Union(_, lhs, rhs) => {
                // Union creates an equality
                let mut subterms = HashSet::default();
                let lhs_term = self.evaluate_expr(lhs, var_map, &mut subterms)?;
                let rhs_term = self.evaluate_expr(rhs, var_map, &mut subterms)?;

                // Add all subexpression terms
                for term in subterms {
                    propositions.insert(Proposition::TermOk(term));
                }

                // Add the equality proposition
                propositions.insert(Proposition::TermsEq(lhs_term, rhs_term));
            }
            ResolvedAction::Change(_, _, _, _) => {
                // Change modifies the egraph state but doesn't produce new propositions
            }
            ResolvedAction::Panic(_, _) => {
                // Panic actions abort execution - they don't produce propositions
            }
            ResolvedAction::Expr(_, expr) => {
                let mut subterms = HashSet::default();
                let term = self.evaluate_expr(expr, var_map, &mut subterms)?;
                propositions.insert(Proposition::TermOk(term));
                // Add all subexpression terms
                for term in subterms {
                    propositions.insert(Proposition::TermOk(term));
                }
            }
        }

        Ok(propositions)
    }

    /// Apply substitution to the rule's query to get expected propositions
    fn get_query_propositions(
        &mut self,
        rule: &ResolvedRule,
        subst: &[RuleVarBinding],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        // Build a substitution map from variable names to TermIds
        let mut var_map: HashMap<String, TermId> = HashMap::default();
        for binding in subst {
            var_map.insert(binding.name.to_string(), binding.term);
        }

        // Process each fact in the rule body
        for fact in rule.body.iter() {
            let prop = self.get_propositions_from_fact(fact, &var_map)?;
            result.insert(prop);
        }

        Ok(result)
    }

    /// Extract propositions from the proof premises
    fn get_premise_propositions(
        &mut self,
        body_pfs: &[Premise],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        for premise in body_pfs.iter() {
            match premise {
                Premise::TermOk(term_pf) => {
                    let prop = self.check_term_proof(*term_pf)?;
                    result.insert(prop);
                }
                Premise::Eq(eq_pf) => {
                    let prop = self.check_eq_proof(*eq_pf)?;
                    result.insert(prop);
                }
            }
        }

        Ok(result)
    }
}
