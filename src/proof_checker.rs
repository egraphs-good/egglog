//! Proof checker for egglog proofs
//!
//! This module provides a proof checker that validates proofs generated by egglog.
//! The checker ensures that proof objects correctly justify the equality or term
//! existence claims they make.
//!
//! ## Example
//! ```
//! use egglog::*;
//! use egglog::prelude::*;
//!
//! // Create an egraph with proofs enabled
//! let mut egraph = EGraph::with_proofs();
//!
//! // Define a simple datatype and global
//! egraph.parse_and_run_program(None,
//!     "(datatype Math (Num i64))\n
//!      (let x (Num 42))"
//! ).unwrap();
//!
//! // Get the value for x
//! let x_expr = egglog::ast::GenericExpr::Var(span!(), "x".to_string());
//! let (_, x_val) = egraph.eval_expr(&x_expr).unwrap();
//!
//! // Get the proof store and explain why x exists
//! let mut store = ProofStore::default();
//! let proof_id = egraph.explain_term(x_val, &mut store).unwrap();
//!
//! let mut output = Vec::new();
//! store.print_term_proof(proof_id, &mut output).unwrap();
//! ```

use crate::ast::{Action, ResolvedAction, ResolvedCommand};
use crate::{
    ArcSort, ProofStore, TypeInfo,
    ast::{Command, GenericExpr, GenericFact, GenericRule, collect_query_vars},
    proof_type_inference::TypeInferenceContext,
    typechecking::PrimitiveWithId,
    util::HashMap,
    util::HashSet,
    util::SymbolGen,
};
use crate::{GenericAction, ResolvedExpr};
use egglog_ast::span::Span;
use egglog_bridge::{
    proof_format::{EqProof, EqProofId, Premise, RuleVarBinding, TermProof, TermProofId},
    termdag::{Term, TermId},
};

/// Represents a proposition that can be proven
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub enum Proposition {
    /// A term is well-formed (exists in the e-graph)
    TermOk(TermId),
    /// Two terms are equal
    TermsEq(TermId, TermId),
}

/// Errors that can occur during proof checking
#[derive(Debug, Clone)]
pub enum ProofCheckError {
    /// The proof is invalid
    InvalidProof(String),
    /// Rule not found in program
    RuleNotFound(String),
    /// Substitution error
    SubstitutionError(String),
    /// Type mismatch
    TypeMismatch(String),
    /// Invalid premise
    InvalidPremise(String),
    /// Term not found
    TermNotFound,
    /// Invalid projection
    InvalidProjection,
    /// Transitivity error
    TransitivityError,
    /// Other error
    Other(String),
}

impl std::fmt::Display for ProofCheckError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProofCheckError::InvalidProof(s) => write!(f, "Invalid proof: {}", s),
            ProofCheckError::RuleNotFound(s) => write!(f, "Rule not found: {}", s),
            ProofCheckError::SubstitutionError(s) => write!(f, "Substitution error: {}", s),
            ProofCheckError::TypeMismatch(s) => write!(f, "Type mismatch: {}", s),
            ProofCheckError::InvalidPremise(s) => write!(f, "Invalid premise: {}", s),
            ProofCheckError::TermNotFound => write!(f, "Term not found"),
            ProofCheckError::InvalidProjection => write!(f, "Invalid projection"),
            ProofCheckError::TransitivityError => write!(f, "Transitivity error"),
            ProofCheckError::Other(s) => write!(f, "Error: {}", s),
        }
    }
}

impl std::error::Error for ProofCheckError {}

/// A proof checker that validates egglog proofs
pub struct ProofChecker<'a> {
    proof_store: &'a mut ProofStore,
    program: Vec<ResolvedCommand>,
    /// Reverse mapping from TermId to global name
    term_to_global: HashMap<TermId, String>,
    /// Set of equalities established by global union actions
    /// Each entry is a pair (lhs, rhs) that was unified
    global_unions: HashSet<(TermId, TermId)>,
    type_info: &'a TypeInfo,
}

impl<'a> ProofChecker<'a> {
    /// Create a new proof checker
    pub fn new(
        proof_store: &'a mut ProofStore,
        program: Vec<ResolvedCommand>,
        type_info: &'a TypeInfo,
    ) -> Self {
        let mut checker = ProofChecker {
            proof_store,
            program,
            term_to_global: HashMap::default(),
            global_unions: HashSet::default(),
            type_info,
        };

        // Process globals to get their actual TermIds
        checker.process_globals();
        checker
    }

    /// Process global definitions and evaluate them to produce [`TermId`]s
    fn process_globals(&mut self) {
        // Process globals in order, building up the mapping
        let program_cmds = self.program.clone();

        for cmd in &program_cmds {
            match cmd {
                ResolvedCommand::Action(ResolvedAction::Union(_, lhs, rhs)) => {
                    // Track global union actions
                    if let (Ok(lhs_term), Ok(rhs_term)) = (
                        self.evaluate_expr(lhs, &HashMap::default()),
                        self.evaluate_expr(rhs, &HashMap::default()),
                    ) {
                        // Store both directions of the equality
                        self.global_unions.insert((lhs_term, rhs_term));
                        self.global_unions.insert((rhs_term, lhs_term));
                        // Store reflexive equalities as well
                        self.global_unions.insert((lhs_term, lhs_term));
                        self.global_unions.insert((rhs_term, rhs_term));
                    }
                }
                _ => {}
            }
        }
    }

    /// Apply a substitution to an expression, replacing variables with terms
    /// Unified expression evaluation that handles both variables and globals
    /// The environment can contain both substituted variables and global definitions
    /// This is used by queries, actions, and global evaluation  
    fn evaluate_expr(
        &mut self,
        expr: &ResolvedExpr,
        env: &HashMap<String, TermId>,
    ) -> Result<TermId, ProofCheckError> {
        match expr {
            GenericExpr::Var(_, name) => env.get(name).cloned().ok_or_else(|| {
                ProofCheckError::SubstitutionError(format!(
                    "Variable or global '{}' not found in environment",
                    name
                ))
            }),
            GenericExpr::Lit(_, lit) => Ok(self.proof_store.make_lit(lit.clone())),
            GenericExpr::Call(_, func, args) => {
                let arg_terms: Result<Vec<_>, _> = args
                    .iter()
                    .map(|arg| self.evaluate_expr(arg, env))
                    .collect();
                let arg_terms = arg_terms?;

                // TODO finish migrating to ResolvedCommand
                // Create the app term
                let app_term = self.proof_store.make_app(func.clone(), arg_terms.clone());

                // Check if this is a primitive that we can evaluate
                if let Some(prims) = self.type_info.get_prims(func) {
                    if let Some(result_term) =
                        self.evaluate_primitive(func, &arg_terms, app_term, prims)?
                    {
                        return Ok(result_term);
                    }
                }

                // Return the app term if not a computable primitive
                Ok(app_term)
            }
        }
    }

    /// Evaluate an expression and collect all subexpression terms created
    /// Returns the main term and a vector of all intermediate terms (including the main term)
    fn evaluate_expr_with_subterms(
        &mut self,
        expr: &GenericExpr<String, String>,
        env: &HashMap<String, TermId>,
    ) -> Result<(TermId, Vec<TermId>), ProofCheckError> {
        let mut all_terms = Vec::new();

        match expr {
            GenericExpr::Var(_, name) => {
                let term = env.get(name).cloned().ok_or_else(|| {
                    ProofCheckError::SubstitutionError(format!(
                        "Variable or global '{}' not found in environment",
                        name
                    ))
                })?;
                // Variables don't create new terms, just reference existing ones
                Ok((term, vec![]))
            }
            GenericExpr::Lit(_, lit) => {
                let term = self.proof_store.make_lit(lit.clone());
                all_terms.push(term);
                Ok((term, all_terms))
            }
            GenericExpr::Call(_, func, args) => {
                // Check if it's a global reference
                if args.is_empty() && self.global_terms.contains_key(func) {
                    let term = self.global_terms[func];
                    // Global references don't create new terms
                    return Ok((term, vec![]));
                }

                // Evaluate all arguments and collect their subterms
                let mut arg_term_ids = Vec::new();
                for arg in args {
                    let (term, mut subterms) = self.evaluate_expr_with_subterms(arg, env)?;
                    arg_term_ids.push(term);
                    all_terms.append(&mut subterms);
                }

                // Create the app term
                let app_term = self
                    .proof_store
                    .make_app(func.clone(), arg_term_ids.clone());
                all_terms.push(app_term);

                // Check if this is a primitive that we can evaluate
                if let Some(prims) = self.type_info.get_prims(func) {
                    if let Some(result_term) =
                        self.evaluate_primitive(func, &arg_term_ids, app_term, prims)?
                    {
                        // For primitives, we return the evaluated result
                        // The app_term is already in all_terms
                        if result_term != app_term {
                            all_terms.push(result_term);
                        }
                        return Ok((result_term, all_terms));
                    }
                }

                // Return the app term and all subterms if not a computable primitive
                Ok((app_term, all_terms))
            }
        }
    }

    /// Returns Some(term) if this is a primitive and it was successfully evaluated,
    /// or None if no primitives match the given function name and argument types.
    /// Errors if a primitive matches but fails to evaluate (for safety).
    fn evaluate_primitive(
        &mut self,
        func: &str,
        arg_terms: &[TermId],
        app_term: TermId,
        prims: &[PrimitiveWithId],
    ) -> Result<Option<TermId>, ProofCheckError> {
        // Get the termdag for evaluation
        let termdag = self.proof_store.termdag();

        // Infer the types of the argument terms
        let mut type_ctx = TypeInferenceContext::new(termdag, self.type_info, &self.program);

        let mut arg_types = Vec::new();
        for &arg_term in arg_terms {
            let arg_type = type_ctx.infer_type(arg_term).ok_or_else(|| {
                ProofCheckError::TypeMismatch(format!(
                    "Failed to infer type for argument term {:?}",
                    termdag.get(arg_term)
                ))
            })?;
            arg_types.push(arg_type);
        }

        // Find primitives that accept these argument types
        let matching_prims: Vec<_> = prims
            .iter()
            .filter(|prim| prim.accept(&arg_types, self.type_info))
            .collect();

        // Ensure exactly one primitive matches
        if matching_prims.is_empty() {
            // No primitives match - this might not be a primitive at all
            return Ok(None);
        }

        if matching_prims.len() > 1 {
            return Err(ProofCheckError::TypeMismatch(format!(
                "Ambiguous primitive call '{}' with argument types: {:?}. {} primitives match.",
                func,
                arg_types.iter().map(|t| t.name()).collect::<Vec<_>>(),
                matching_prims.len()
            )));
        }

        let prim = matching_prims[0];

        // If the primitive has a validator, try to evaluate it
        if let Some(validator) = &prim.validator {
            // The validator evaluates the primitive if all arguments are constants
            if let Some(computed_lit) = validator(termdag, app_term) {
                // The primitive computed to a literal value
                return Ok(Some(self.proof_store.make_lit(computed_lit)));
            } else {
                // Validator returned None - evaluation failed
                // This happens if arguments are not constants or if evaluation logic fails
                // For proof checking, we need to ensure primitives always evaluate successfully
                return Err(ProofCheckError::InvalidProof(format!(
                    "Primitive '{}' failed to evaluate with given arguments",
                    func
                )));
            }
        }

        // No validator available - this is an error for proof checking
        // We need to be safe: primitives without validators cannot be trusted in proofs
        Err(ProofCheckError::InvalidProof(format!(
            "Primitive '{}' has no validator and cannot be verified in proofs",
            func
        )))
    }

    /// Infer the type of a term from the termdag.
    /// Get all propositions that a rule can produce given a substitution and premises
    fn rule_propositions(
        &mut self,
        rule: &GenericRule<String, String>,
        subst: &[RuleVarBinding],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        // Build a substitution map from variable names to TermIds
        let mut var_map: HashMap<String, TermId> = HashMap::default();
        for binding in subst {
            var_map.insert(binding.name.to_string(), binding.term);
        }

        // Process each action in the head to see what propositions it produces
        for action in rule.head.iter() {
            let props = self.get_propositions_from_action(action, &var_map)?;
            result.extend(props);
        }

        Ok(result)
    }

    /// Check if a term is a valid PFiat axiom
    fn is_valid_pfiat_term(&self, term: TermId) -> bool {
        let termdag = self.proof_store.termdag();

        // Literals are always valid axioms
        if matches!(termdag.get(term), Term::Lit(_)) {
            return true;
        }

        // Check if we have this exact term registered as a global value
        // This ensures we're not accepting arbitrary terms, only ones we computed
        for (_name, &global_term) in &self.global_terms {
            if global_term == term {
                return true;
            }
        }

        // Check if it's a global variable defined via (let x expr)
        if let Term::App(name, args) = termdag.get(term) {
            // Global variables are 0-ary functions
            if args.is_empty() {
                if let Some(&_global_value) = self.global_terms.get(name) {
                    // For a global reference to be valid, the term should match
                    // the reference itself (not its value)
                    return self.term_to_global.contains_key(&term);
                }
            }
        }

        false
    }

    /// Check if a function is a primitive operation
    /// Check a term proof
    pub fn check_term_proof(
        &mut self,
        proof_id: TermProofId,
    ) -> Result<Proposition, ProofCheckError> {
        let proof = self
            .proof_store
            .term_proof(proof_id)
            .ok_or(ProofCheckError::TermNotFound)?
            .clone(); // Clone to avoid borrow issues

        match proof {
            TermProof::PRule {
                rule_name,
                subst,
                body_pfs,
                result,
            } => {
                // Check that:
                // 1. The rule exists and fires with the given substitution
                // 2. The rule's head, when instantiated with the substitution, produces the result
                let rule = self.find_rule(&rule_name)?.clone();
                self.check_rule_fires(&rule_name, &subst, &body_pfs)?;

                // Get all propositions the rule can produce
                let propositions = self.rule_propositions(&rule, &subst)?;

                // Check if the result term is in the set of propositions
                if !propositions.contains(&Proposition::TermOk(result)) {
                    return Err(ProofCheckError::InvalidProof(format!(
                        "Rule does not produce the expected term {:?}",
                        result
                    )));
                }

                Ok(Proposition::TermOk(result))
            }
            TermProof::PProj {
                pf_f_args_ok,
                arg_idx,
            } => {
                // Check that the parent term is valid and project to child
                let parent_prop = self.check_term_proof(pf_f_args_ok)?;
                match parent_prop {
                    Proposition::TermOk(term_id) => {
                        // Get the children of the term through ProofStore's termdag
                        let children = self.proof_store.get_term_children(term_id);
                        if arg_idx < children.len() {
                            Ok(Proposition::TermOk(children[arg_idx]))
                        } else {
                            Err(ProofCheckError::InvalidProjection)
                        }
                    }
                    _ => Err(ProofCheckError::TypeMismatch(
                        "Expected term proof".to_string(),
                    )),
                }
            }
            TermProof::PCong(cong_proof) => {
                // Check congruence proof:
                // 1. The original term exists
                // 2. All arguments have equality proofs
                // 3. The new term is constructed correctly with rewritten arguments

                // Check that the original term exists
                let parent_prop = self.check_term_proof(cong_proof.pf_f_args_ok)?;
                let old_term = match parent_prop {
                    Proposition::TermOk(term) => term,
                    _ => {
                        return Err(ProofCheckError::TypeMismatch(
                            "Expected term proof for congruence".to_string(),
                        ));
                    }
                };

                // Get the structure of the old term
                let (func_name, old_args) = match self.proof_store.termdag().get(old_term) {
                    Term::App(func, args) => (func.clone(), args.clone()),
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence proof requires function application".to_string(),
                        ));
                    }
                };

                // Check that we have the right number of equality proofs
                if cong_proof.pf_args_eq.len() != old_args.len() {
                    return Err(ProofCheckError::InvalidProof(
                        "Wrong number of argument proofs in congruence".to_string(),
                    ));
                }

                // Check all child equality proofs and collect new arguments
                let mut new_args = Vec::new();
                let old_args_cloned = old_args.clone();
                for (i, eq_pf) in cong_proof.pf_args_eq.iter().enumerate() {
                    let eq_prop = self.check_eq_proof(*eq_pf)?;
                    match eq_prop {
                        Proposition::TermsEq(lhs, rhs) => {
                            // Verify that lhs matches the original argument
                            if lhs != old_args_cloned[i] {
                                return Err(ProofCheckError::InvalidProof(format!(
                                    "Congruence argument {} mismatch",
                                    i
                                )));
                            }
                            new_args.push(rhs);
                        }
                        _ => {
                            return Err(ProofCheckError::TypeMismatch(
                                "Expected equality proof".to_string(),
                            ));
                        }
                    }
                }

                // Verify that the new term is constructed correctly
                // Construct the expected new term directly and verify it matches
                let expected_new_term = self.proof_store.make_app(func_name, new_args.clone());

                // Verify that the claimed new term matches what we constructed
                if cong_proof.new_term != expected_new_term {
                    // Get detailed information for error reporting
                    let actual_structure = self.proof_store.termdag().get(cong_proof.new_term);
                    let expected_structure = self.proof_store.termdag().get(expected_new_term);
                    return Err(ProofCheckError::InvalidProof(format!(
                        "Congruence new term mismatch. Expected term {:?} (structure: {:?}) but got term {:?} (structure: {:?})",
                        expected_new_term,
                        expected_structure,
                        cong_proof.new_term,
                        actual_structure
                    )));
                }

                Ok(Proposition::TermOk(cong_proof.new_term))
            }
            TermProof::PFiat { desc: _, term } => {
                // PFiat should only be used for terms declared globally or literals.
                if self.is_valid_pfiat_term(term) {
                    return Ok(Proposition::TermOk(term));
                }

                let term_str = format!("{:?}", term);
                Err(ProofCheckError::InvalidProof(format!(
                    "PFiat proof for term '{}' does not correspond to a known global or literal.",
                    term_str
                )))
            }
        }
    }

    /// Check an equality proof
    pub fn check_eq_proof(&mut self, proof_id: EqProofId) -> Result<Proposition, ProofCheckError> {
        let proof = self
            .proof_store
            .eq_proof(proof_id)
            .ok_or(ProofCheckError::TermNotFound)?
            .clone(); // Clone to avoid borrow issues

        match proof {
            EqProof::PRule {
                rule_name,
                subst,
                body_pfs,
                result_lhs,
                result_rhs,
            } => {
                // Check that:
                // 1. The rule exists and fires with the given substitution
                // 2. The rule's head, when instantiated with the substitution, produces the equality
                let rule = self.find_rule(&rule_name)?.clone();
                self.check_rule_fires(&rule_name, &subst, &body_pfs)?;

                // Get all propositions the rule can produce
                let propositions = self.rule_propositions(&rule, &subst)?;

                // Check if the equality is in the set of propositions
                let prop = Proposition::TermsEq(result_lhs, result_rhs);
                if !propositions.contains(&prop) {
                    // Also check the symmetric version
                    let prop_sym = Proposition::TermsEq(result_rhs, result_lhs);
                    if !propositions.contains(&prop_sym) {
                        return Err(ProofCheckError::InvalidProof(format!(
                            "Rule does not produce the expected equality {:?} = {:?}",
                            result_lhs, result_rhs
                        )));
                    }
                }

                Ok(Proposition::TermsEq(result_lhs, result_rhs))
            }
            EqProof::PRefl { t_ok_pf, t } => {
                // Check that the term is valid
                let prop = self.check_term_proof(t_ok_pf)?;
                match prop {
                    Proposition::TermOk(term) if term == t => Ok(Proposition::TermsEq(t, t)),
                    _ => Err(ProofCheckError::InvalidProof(
                        "Reflexivity proof term mismatch".to_string(),
                    )),
                }
            }
            EqProof::PSym { eq_pf } => {
                // Check symmetry
                let prop = self.check_eq_proof(eq_pf)?;
                match prop {
                    Proposition::TermsEq(a, b) => Ok(Proposition::TermsEq(b, a)),
                    _ => Err(ProofCheckError::TypeMismatch(
                        "Expected equality proof".to_string(),
                    )),
                }
            }
            EqProof::PTrans { pfxy, pfyz } => {
                // Check transitivity
                let prop_xy = self.check_eq_proof(pfxy)?;
                let prop_yz = self.check_eq_proof(pfyz)?;
                match (prop_xy, prop_yz) {
                    (Proposition::TermsEq(x, y1), Proposition::TermsEq(y2, z)) if y1 == y2 => {
                        Ok(Proposition::TermsEq(x, z))
                    }
                    _ => Err(ProofCheckError::TransitivityError),
                }
            }
            EqProof::PCong(cong_proof) => {
                // Check congruence for equality:
                // 1. The original term exists
                // 2. All arguments have equality proofs
                // 3. The new term is constructed correctly with rewritten arguments

                // Check that the original term exists
                let parent_prop = self.check_term_proof(cong_proof.pf_f_args_ok)?;
                let old_term = match parent_prop {
                    Proposition::TermOk(term) => term,
                    _ => {
                        return Err(ProofCheckError::TypeMismatch(
                            "Expected term proof for congruence".to_string(),
                        ));
                    }
                };

                // Verify old_term matches what's in the congruence proof
                if old_term != cong_proof.old_term {
                    return Err(ProofCheckError::InvalidProof(
                        "Congruence old term mismatch".to_string(),
                    ));
                }

                // Get the structure of the old term
                let (func_name, old_args) = match self.proof_store.termdag().get(old_term) {
                    Term::App(func, args) => (func.clone(), args.clone()),
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence proof requires function application".to_string(),
                        ));
                    }
                };

                // Check that we have the right number of equality proofs
                if cong_proof.pf_args_eq.len() != old_args.len() {
                    return Err(ProofCheckError::InvalidProof(
                        "Wrong number of argument proofs in congruence".to_string(),
                    ));
                }

                // Check all child equality proofs and collect new arguments
                let mut new_args = Vec::new();
                let old_args_cloned = old_args.clone();
                for (i, eq_pf) in cong_proof.pf_args_eq.iter().enumerate() {
                    let eq_prop = self.check_eq_proof(*eq_pf)?;
                    match eq_prop {
                        Proposition::TermsEq(lhs, rhs) => {
                            // Verify that lhs matches the original argument
                            if lhs != old_args_cloned[i] {
                                return Err(ProofCheckError::InvalidProof(format!(
                                    "Congruence argument {} mismatch",
                                    i
                                )));
                            }
                            new_args.push(rhs);
                        }
                        _ => {
                            return Err(ProofCheckError::TypeMismatch(
                                "Expected equality proof".to_string(),
                            ));
                        }
                    }
                }

                // Verify that the new term is constructed correctly
                // Verify that the new term is constructed correctly by checking:
                // 1. The function name is the same
                // 2. The arguments match the rewritten arguments from the equality proofs
                let new_term_structure = self.proof_store.termdag().get(cong_proof.new_term);
                match new_term_structure {
                    Term::App(new_func, actual_new_args) => {
                        if new_func != &func_name || actual_new_args != &new_args {
                            return Err(ProofCheckError::InvalidProof(format!(
                                "Congruence new term doesn't match expected construction. Expected {}({:?}) but got {}({:?})",
                                func_name, new_args, new_func, actual_new_args
                            )));
                        }
                    }
                    _ => {
                        return Err(ProofCheckError::InvalidProof(
                            "Congruence new term should be a function application".to_string(),
                        ));
                    }
                }

                Ok(Proposition::TermsEq(
                    cong_proof.old_term,
                    cong_proof.new_term,
                ))
            }
            EqProof::PFiat { desc: _, lhs, rhs } => {
                // PFiat equalities should only be used for global union actions
                // Check if this equality was established by a global union action
                if self.global_unions.contains(&(lhs, rhs)) {
                    Ok(Proposition::TermsEq(lhs, rhs))
                } else {
                    Err(ProofCheckError::InvalidProof(format!(
                        "PFiat equality ({:?}, {:?}) does not correspond to a global union action",
                        lhs, rhs
                    )))
                }
            }
        }
    }

    /// Check that a rule fires with the given substitution and premises
    fn check_rule_fires(
        &mut self,
        rule_name: &str,
        subst: &[RuleVarBinding],
        body_pfs: &[Premise],
    ) -> Result<(), ProofCheckError> {
        // Check for duplicate variable bindings
        let mut seen_vars = HashSet::default();
        for binding in subst {
            if !seen_vars.insert(&binding.name) {
                return Err(ProofCheckError::InvalidProof(format!(
                    "Duplicate variable binding for '{}' in rule '{}'",
                    binding.name, rule_name
                )));
            }
        }

        // Find the rule in the program
        let rule = self.find_rule(rule_name)?.clone();

        // Type check substitution variables
        self.typecheck_substitution(&rule, subst)?;

        // Rules with empty bodies (no query) are axioms that require no premises to fire
        // They can produce terms/equalities unconditionally
        if rule.body.is_empty() {
            // Empty body = no premises required, this is valid
            if !body_pfs.is_empty() {
                return Err(ProofCheckError::InvalidProof(
                    "Empty body rule should have no premises".to_string(),
                ));
            }
            return Ok(());
        }

        // Get the expected propositions by applying substitution to the rule's query
        let expected_props = self.get_query_propositions(&rule, subst)?;

        // Get the actual propositions from the proof premises
        let actual_props = self.get_premise_propositions(body_pfs)?;

        // Check that the propositions match exactly
        if expected_props != actual_props {
            return Err(ProofCheckError::InvalidProof(format!(
                "Rule '{}' premises don't match expected propositions. Expected: {:?}, Got: {:?}",
                rule_name, expected_props, actual_props
            )));
        }

        Ok(())
    }

    /// Collect all variable names from a fact
    /// Find a rule by name in the program
    fn find_rule(&self, rule_name: &str) -> Result<&GenericRule<String, String>, ProofCheckError> {
        for cmd in &self.program {
            if let Command::Rule { rule } = cmd {
                if rule.name == rule_name {
                    return Ok(rule);
                }
            }
        }
        Err(ProofCheckError::RuleNotFound(rule_name.to_string()))
    }

    /// Type check the substitution to ensure variables match expected types.
    /// An external proof checker would have trouble with this step, so we should consider adding type annotations
    /// to the egglog
    fn typecheck_substitution(
        &mut self,
        rule: &GenericRule<String, String>,
        subst: &[RuleVarBinding],
    ) -> Result<(), ProofCheckError> {
        // Create a temporary SymbolGen for type checking
        let mut symbol_gen = SymbolGen::new("proof_check_".into());

        // Type check the rule's body to get expected variable types
        let resolved_facts = self
            .type_info
            .typecheck_facts(&mut symbol_gen, &rule.body)
            .map_err(|e| {
                ProofCheckError::TypeMismatch(format!("Failed to typecheck rule body: {}", e))
            })?;

        // Collect expected variable types from the resolved facts
        let expected_vars = collect_query_vars(&resolved_facts);
        let expected_types: HashMap<std::sync::Arc<str>, ArcSort> = expected_vars
            .into_iter()
            .map(|(var, sort)| (var.name().to_string().into(), sort))
            .collect();

        // Check each substitution binding
        for binding in subst {
            // Skip internal variables (starting with '$')
            if binding.name.starts_with('$') {
                continue;
            }

            // Check if this variable exists in the rule
            let expected_sort = expected_types.get(&binding.name[..]).ok_or_else(|| {
                ProofCheckError::InvalidProof(format!(
                    "Substitution contains unexpected variable '{}' not found in rule body",
                    binding.name
                ))
            })?;

            // Infer the type of the substituted term
            let termdag = self.proof_store.termdag();
            let mut type_context =
                TypeInferenceContext::new(termdag, self.type_info, &self.program);
            let inferred_sort = type_context.infer_type(binding.term).ok_or_else(|| {
                ProofCheckError::TypeMismatch(format!(
                    "Failed to infer type for substituted term in variable '{}'",
                    binding.name
                ))
            })?;

            // Check if the types match
            if inferred_sort.name() != expected_sort.name() {
                return Err(ProofCheckError::TypeMismatch(format!(
                    "Type mismatch for variable '{}': expected {}, got {}",
                    binding.name,
                    expected_sort.name(),
                    inferred_sort.name()
                )));
            }
        }

        Ok(())
    }

    /// Construct a term from an expression with variable substitution
    fn construct_term_from_expr(
        &mut self,
        expr: &GenericExpr<String, String>,
        var_map: &HashMap<String, TermId>,
    ) -> Result<TermId, ProofCheckError> {
        // Use the unified evaluation function
        self.evaluate_expr(expr, var_map)
    }

    /// Shared method to get propositions from expressions or facts
    /// This handles queries, globals, and actions uniformly including primitives
    fn get_propositions_from_fact(
        &mut self,
        fact: &GenericFact<String, String>,
        var_map: &HashMap<String, TermId>,
    ) -> Result<Proposition, ProofCheckError> {
        match fact {
            GenericFact::Eq(_, lhs, rhs) => {
                let lhs_term = self.construct_term_from_expr(lhs, var_map)?;
                let rhs_term = self.construct_term_from_expr(rhs, var_map)?;
                Ok(Proposition::TermsEq(lhs_term, rhs_term))
            }
            GenericFact::Fact(expr) => {
                let term = self.construct_term_from_expr(expr, var_map)?;
                Ok(Proposition::TermOk(term))
            }
        }
    }

    /// Get propositions from an action (for rule heads)
    fn get_propositions_from_action(
        &mut self,
        action: &GenericAction<String, String>,
        var_map: &HashMap<String, TermId>,
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut propositions = HashSet::default();

        match action {
            GenericAction::Let(_, name, expr) => {
                // Let creates a term
                let _ = name; // Suppress unused warning
                let (_term, subterms) = self.evaluate_expr_with_subterms(expr, var_map)?;
                // Add all subexpression terms
                for term in subterms {
                    propositions.insert(Proposition::TermOk(term));
                }
            }
            GenericAction::Set(_, lhs, args, rhs) => {
                // Set creates an equality (f(args) = rhs)
                let app_expr = GenericExpr::Call(Span::Panic, lhs.clone(), args.clone());
                let (lhs_term, lhs_subterms) =
                    self.evaluate_expr_with_subterms(&app_expr, var_map)?;
                let (rhs_term, rhs_subterms) = self.evaluate_expr_with_subterms(rhs, var_map)?;

                // Add all subexpression terms
                for term in lhs_subterms {
                    propositions.insert(Proposition::TermOk(term));
                }
                for term in rhs_subterms {
                    propositions.insert(Proposition::TermOk(term));
                }

                // Add the equality proposition
                propositions.insert(Proposition::TermsEq(lhs_term, rhs_term));
            }
            GenericAction::Union(_, lhs, rhs) => {
                // Union creates an equality
                let (lhs_term, lhs_subterms) = self.evaluate_expr_with_subterms(lhs, var_map)?;
                let (rhs_term, rhs_subterms) = self.evaluate_expr_with_subterms(rhs, var_map)?;

                // Add all subexpression terms
                for term in lhs_subterms {
                    propositions.insert(Proposition::TermOk(term));
                }
                for term in rhs_subterms {
                    propositions.insert(Proposition::TermOk(term));
                }

                // Add the equality proposition
                propositions.insert(Proposition::TermsEq(lhs_term, rhs_term));
            }
            GenericAction::Change(_, _, _, _) => {
                // Change modifies the egraph state but doesn't produce new propositions
            }
            GenericAction::Panic(_, _) => {
                // Panic actions abort execution - they don't produce propositions
            }
            GenericAction::Expr(_, expr) => {
                // Expr actions evaluate expressions
                let (_term, subterms) = self.evaluate_expr_with_subterms(expr, var_map)?;
                // Add all subexpression terms
                for term in subterms {
                    propositions.insert(Proposition::TermOk(term));
                }
            }
        }

        Ok(propositions)
    }

    /// Apply substitution to the rule's query to get expected propositions
    fn get_query_propositions(
        &mut self,
        rule: &GenericRule<String, String>,
        subst: &[RuleVarBinding],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        // Build a substitution map from variable names to TermIds
        let mut var_map: HashMap<String, TermId> = HashMap::default();
        for binding in subst {
            var_map.insert(binding.name.to_string(), binding.term);
        }

        // Process each fact in the rule body
        for fact in rule.body.iter() {
            let prop = self.get_propositions_from_fact(fact, &var_map)?;
            result.insert(prop);
        }

        Ok(result)
    }

    /// Extract propositions from the proof premises
    fn get_premise_propositions(
        &mut self,
        body_pfs: &[Premise],
    ) -> Result<HashSet<Proposition>, ProofCheckError> {
        let mut result = HashSet::default();

        for premise in body_pfs.iter() {
            match premise {
                Premise::TermOk(term_pf) => {
                    let prop = self.check_term_proof(*term_pf)?;
                    result.insert(prop);
                }
                Premise::Eq(eq_pf) => {
                    let prop = self.check_eq_proof(*eq_pf)?;
                    result.insert(prop);
                }
            }
        }

        Ok(result)
    }
}
