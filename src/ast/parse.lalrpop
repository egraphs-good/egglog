use crate::ast::*;
use crate::Symbol;
use num_rational::BigRational;

grammar;

extern {
    type Error = String;
}

// lexer
match {
    r"\s*" => { }, // skip whitespace
    r";[^\n\r]*[\n\r]*" => { }, // skip ; comments
    r"Int|int|I64|number" => reserved,
    _
}

pub Program: Vec<Command> = { (Command)* => <> }

List<T>: Vec<T> = { 
    "(" <T*> ")" => <>,
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Command: Command = {
    "(" "datatype" <name:Ident> <variants:(Variant)*> ")" => Command::Datatype { <> },
    "(" "function" <name:Ident> <schema:Schema> ")" => Command::Function(FunctionDecl { name, schema }),
    "(" "relation" <name:Ident> <types:List<InputType>> ")" => Command::Function(FunctionDecl::relation(name, types)),
    "(" "rule" <body:List<Fact>> <head:List<Fact>> ")" => Command::Rule(Rule { head, body }),
    "(" "rewrite" <lhs:Expr> <rhs:Expr> ")" => Command::Rewrite(Rewrite { <> }),
    "(" "define" <name:Ident> <expr:Expr> ")" => Command::Define(name, expr),
    "(" "assert" <Fact> ")" => Command::Fact(<>),
    "(" "run" <Num> ")" => Command::Run(<>.try_into().unwrap()),
    "(" "extract" <Expr> ")" => Command::Extract(<>),
    "(" "check" <Fact> ")" => Command::Check(<>),
    "(" "dl" <DLCommand> ")" => <>
}

DLCommand : Command = {
    <DLFact> "." => Command::Fact(<>),
    <head:Comma<DLFact>> ":-" <body:Comma<DLFact>> "." => Command::Rule(Rule {head, body})
}

DLFact : Fact = {
    <DLExpr> => Fact::Fact(<>)
}

DLExpr : Expr = {
    <Literal> => Expr::Lit(<>),
    <Ident> => Expr::Var(<>),
    <f:Ident> "(" <args:Comma<DLExpr>> ")" => Expr::Call(f, args)
}

Name: Symbol = { "[" <Ident> "]" => <> }

Fact: Fact = {
    "(" "=" <mut es:Expr+> <e:Expr> ")" => {
        es.push(e);
        Fact::Eq(es)
    },
    <Expr> => Fact::Fact(<>),
}

Schema: Schema = {
    <types:List<InputType>> <output:OutputType> => Schema { input: types, output }
}

Expr: Expr = {
    <Literal> => Expr::Lit(<>),
    <Ident> => Expr::Var(<>),
    <CallExpr> => <>,
    "(" <head:PrimitiveSymbol> <tail:(Expr)+> ")" => Expr::Call(head, tail),
};

Literal: Literal = {
    <Num> => Literal::Int(<>),
    <numer:Num> "//" <denom:Num> => Literal::Rational(BigRational::new(numer.into(), denom.into())),
    <SymString> => Literal::String(<>),
}

CallExpr: Expr = {
    "(" <head:Ident> <tail:(Expr)*> ")" => Expr::Call(head, tail),
}

ExprList: Vec<Expr> = { "(" <sexps:(Expr)*> ")" => sexps }

Variant: Variant = {
    "(" <name:Ident> <types:(InputType)*> ")" => Variant { <> },
}

InputType: InputType = { 
    "String" => InputType::String,
    <NumType> => InputType::NumType(<>),
    <Ident> => InputType::Sort(<>),
}

NumType: NumType = {
    "i64" => NumType::I64,
    "rational" => NumType::Rational,
    <s:reserved> =>? lalrpop_error!("{} is reserved.", s)
    // "f64" => NumType::F64,
}

OutputType: OutputType = {
    <InputType> => OutputType::Type(<>),
    "(" "Max" <NumType> ")" => OutputType::Max(<>),
    "(" "Min" <NumType> ")" => OutputType::Min(<>),
}

Num: i64 = <s:r"(-)?[0-9]+"> => s.parse().unwrap();
Bool: bool = {
    "true" => true,
    "false" => false,
}
Ident: Symbol = <s:r"[[:alpha:]][\w-]*"> => s.parse().unwrap();
PrimitiveSymbol: Symbol = <r"[!+*/-][=!+*/-]+"> => Symbol::from(<>);
SymString: Symbol = <r#""[^"]*""#> => Symbol::from(<>);