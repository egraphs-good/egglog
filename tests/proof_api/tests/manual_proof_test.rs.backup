use egglog::*;
use std::rc::Rc;
use std::sync::Arc;
use egglog::sort::ColumnTy;

#[test]
fn test_rule_based_proofs() {
    // Create an egglog program with actual rules
    let program = r#"
        (datatype Math
            (Num i64)
            (Add Math Math)
            (Mul Math Math))
        
        ; Commutativity rules
        (rule ((= x (Add a b))) 
              ((union x (Add b a))))
        
        (rule ((= x (Mul a b)))
              ((union x (Mul b a))))
        
        ; Associativity rule for addition
        (rule ((= x (Add (Add a b) c)))
              ((union x (Add a (Add b c)))))
        
        ; Create some initial terms
        (let t1 (Add (Num 1) (Num 2)))
        (let t2 (Mul (Num 3) (Num 4)))
        (let t3 (Add t1 (Num 5)))
        
        ; Run for a few iterations to generate proofs
        (run 3)
        
        ; Now check that rules created proofs
        (check (= t1 (Add (Num 2) (Num 1))))
        (check (= t2 (Mul (Num 4) (Num 3))))
        (check (= t3 (Add (Num 1) (Add (Num 2) (Num 5)))))
    "#;
    
    // Create an egraph with proofs enabled
    let mut egraph = EGraph::with_proofs();
    
    // Parse and run the program directly
    let outputs = match egraph.parse_and_run_program(None, program) {
        Ok(o) => o,
        Err(e) => {
            panic!("Failed to run program: {}", e);
        }
    };
    
    
    // The fact that the program ran without panicking means all checks passed
    // and the rule-based proofs exist and work correctly
    
    // Verify the egraph has proofs enabled
    assert!(egraph.proofs_enabled(), "EGraph should have proofs enabled");
    
    // The key test is that our rules fired and created proofs.
    // This is verified by the fact that:
    // 1. The check commands passed (program didn't panic) 
    // 2. Proofs are enabled so checks require valid proofs
    // 3. The checks verified equalities that were created by our rules
    //    (e.g., t1 = (Add (Num 2) (Num 1)) due to commutativity rule)
    
    // The successful execution with proof mode on means rule-based proofs work!
    println!("Successfully ran program with {} outputs, proving rules created valid proofs", outputs.len());
}

#[test]
fn test_manual_proof_construction() {
    // Create a proof store
    let mut store = ProofStore::default();

    // Manually construct terms in the term DAG
    // Create simple literal terms
    let lit42 = store.make_lit(egglog::ast::Literal::Int(42));
    let num_term = store.make_app("Num".to_string(), vec![lit42]);

    let lit1 = store.make_lit(egglog::ast::Literal::Int(1));
    let num1_term = store.make_app("Num".to_string(), vec![lit1]);

    // Create an Add term: (Add (Num 42) (Num 1))
    let add_term = store.make_app("Add".to_string(), vec![num_term, num1_term]);

    // Manually construct a proof that this term is ok (exists)
    // We'll use a fiat proof for simplicity
    let fiat_proof = TermProof::PFiat {
        desc: Rc::from("Manual construction"),
        term: add_term,
    };

    // Add the proof to the store
    let proof_id = store.add_term_proof(&fiat_proof);

    // Verify we can retrieve the proof
    let retrieved_proof = store.term_proof(proof_id);
    assert!(retrieved_proof.is_some(), "Should be able to retrieve proof");

    // Verify the proof matches what we constructed
    if let Some(TermProof::PFiat { desc, term }) = retrieved_proof {
        assert_eq!(desc.as_ref(), "Manual construction");
        assert_eq!(*term, add_term);
    } else {
        panic!("Retrieved proof should be a PFiat proof");
    }

    // Now create a more complex proof using congruence
    // First create proofs for the arguments
    let num_proof = TermProof::PFiat {
        desc: Rc::from("Number literal"),
        term: num_term,
    };
    let num_proof_id = store.add_term_proof(&num_proof);

    let num1_proof = TermProof::PFiat {
        desc: Rc::from("Number literal 1"),
        term: num1_term,
    };
    let _num1_proof_id = store.add_term_proof(&num1_proof);

    // Create a congruence proof for the Add term
    let cong_proof = TermProof::PCong(CongProof {
        pf_args_eq: vec![],  // No equality proofs needed since we're just constructing
        pf_f_args_ok: num_proof_id,  // Using the first arg proof as the base
        old_term: add_term,
        new_term: add_term,  // Same term since no rewriting
        func: Arc::from("Add"),
    });

    let cong_proof_id = store.add_term_proof(&cong_proof);

    // Verify the congruence proof
    let retrieved_cong = store.term_proof(cong_proof_id);
    assert!(retrieved_cong.is_some(), "Should be able to retrieve congruence proof");

    // Test creating a projection proof
    // This extracts an argument from a term proof
    let proj_proof = TermProof::PProj {
        pf_f_args_ok: cong_proof_id,
        arg_idx: 0,  // Extract first argument
    };

    let proj_proof_id = store.add_term_proof(&proj_proof);

    // Verify projection proof
    if let Some(TermProof::PProj { pf_f_args_ok, arg_idx }) = store.term_proof(proj_proof_id) {
        assert_eq!(*pf_f_args_ok, cong_proof_id);
        assert_eq!(*arg_idx, 0);
    } else {
        panic!("Should be a projection proof");
    }

    // Test creating equality proofs
    // Create a reflexivity proof
    let refl_proof = EqProof::PRefl { 
        t: num_term,
        t_ok_pf: num_proof_id,
    };
    let refl_proof_id = store.add_eq_proof(&refl_proof);

    // Verify we can retrieve the reflexivity proof
    let retrieved_refl = store.eq_proof(refl_proof_id);
    assert!(retrieved_refl.is_some(), "Should be able to retrieve reflexivity proof");

    if let Some(EqProof::PRefl { t, .. }) = retrieved_refl {
        assert_eq!(*t, num_term);
    } else {
        panic!("Should be a reflexivity proof");
    }

    // Test creating a symmetry proof
    let sym_proof = EqProof::PSym { eq_pf: refl_proof_id };
    let sym_proof_id = store.add_eq_proof(&sym_proof);

    // Verify symmetry proof
    if let Some(EqProof::PSym { eq_pf }) = store.eq_proof(sym_proof_id) {
        assert_eq!(*eq_pf, refl_proof_id);
    } else {
        panic!("Should be a symmetry proof");
    }

    // Test transitivity proof
    let trans_proof = EqProof::PTrans { 
        pfxy: sym_proof_id,
        pfyz: refl_proof_id,
    };
    let trans_proof_id = store.add_eq_proof(&trans_proof);
    
    // Verify transitivity proof
    if let Some(EqProof::PTrans { pfxy, pfyz }) = store.eq_proof(trans_proof_id) {
        assert_eq!(*pfxy, sym_proof_id);
        assert_eq!(*pfyz, refl_proof_id);
    } else {
        panic!("Should be a transitivity proof");
    }

    // Test creating an equality congruence proof
    // EqProof::PCong takes a CongProof directly
    let eq_cong_proof = EqProof::PCong(CongProof {
        pf_args_eq: vec![refl_proof_id],
        pf_f_args_ok: num_proof_id,
        old_term: add_term,
        new_term: add_term,
        func: Arc::from("Add"),
    });

    let eq_cong_proof_id = store.add_eq_proof(&eq_cong_proof);
    
    // Verify equality congruence proof
    if let Some(EqProof::PCong(CongProof { func, .. })) = store.eq_proof(eq_cong_proof_id) {
        assert_eq!(func.as_ref(), "Add");
    } else {
        panic!("Should be an equality congruence proof");
    }
    
    // Test that we can access the termdag
    let _termdag = store.termdag();
    
    // Test we can get children of a term
    let children = store.get_term_children(add_term);
    assert_eq!(children.len(), 2, "Add should have 2 children");
    
    // Create more complex nested terms
    let nested_add = store.make_app("Add".to_string(), vec![add_term, num_term]);
    let nested_children = store.get_term_children(nested_add);
    assert_eq!(nested_children[0], add_term, "First child should be the original add term");
    
    // Test that we can mutate the termdag
    let termdag_mut = store.termdag_mut();
    let _new_lit = termdag_mut.lit_id(egglog::ast::Literal::Int(100));
}

#[test]
fn test_manual_proof_checking() {
    // Create a proof store
    let mut store = ProofStore::default();
    
    // We need to create a proof that can actually be checked
    // For manual proof checking, we'd need a simpler approach that doesn't
    // require full EGraph setup. Let's construct a simple proof and try to
    // check its structure at least.
    
    // Create a simple literal term
    let lit42 = store.make_lit(egglog::ast::Literal::Int(42));
    
    // Create a fiat proof that this literal exists
    let fiat_proof = TermProof::PFiat {
        desc: Rc::from("Literal 42"),
        term: lit42,
    };
    
    let proof_id = store.add_term_proof(&fiat_proof);
    
    // Now let's try to check structural properties of the proof
    // Without full EGraph, we can at least verify:
    // 1. The proof exists
    // 2. The term structure is valid
    // 3. Proof references are consistent
    
    let proof = store.term_proof(proof_id).expect("Proof should exist");
    
    match proof {
        TermProof::PFiat { .. } => {
            // Verify this is a valid term in the DAG
            let _termdag = store.termdag();
        }
        _ => panic!("Expected fiat proof"),
    }
    
    // Test creating and checking a reflexivity proof
    let refl_proof = EqProof::PRefl {
        t: lit42,
        t_ok_pf: proof_id,
    };
    
    let refl_id = store.add_eq_proof(&refl_proof);
    
    // Verify the reflexivity proof structure
    let refl = store.eq_proof(refl_id).expect("Reflexivity proof should exist");
    
    match refl {
        EqProof::PRefl { t, t_ok_pf } => {
            // Check that the referenced proof exists
            assert!(store.term_proof(*t_ok_pf).is_some(), "Referenced proof should exist");
            // Check that the term matches
            assert_eq!(*t, lit42, "Term should match");
        }
        _ => panic!("Expected reflexivity proof"),
    }
    
    // Test creating a chain of proofs and checking consistency
    let sym_proof = EqProof::PSym { eq_pf: refl_id };
    let sym_id = store.add_eq_proof(&sym_proof);
    
    // Create a transitivity proof
    let trans_proof = EqProof::PTrans {
        pfxy: refl_id,
        pfyz: sym_id,
    };
    let trans_id = store.add_eq_proof(&trans_proof);
    
    // Verify the proof chain
    let trans = store.eq_proof(trans_id).expect("Transitivity proof should exist");
    
    match trans {
        EqProof::PTrans { pfxy, pfyz } => {
            // Both referenced proofs should exist
            assert!(store.eq_proof(*pfxy).is_some(), "First proof should exist");
            assert!(store.eq_proof(*pfyz).is_some(), "Second proof should exist");
        }
        _ => panic!("Expected transitivity proof"),
    }
    
    // Test invalid proof references
    // Try to create a proof with a non-existent reference
    // This should still be storable but would fail actual proof checking
    // Create an invalid proof ID by incrementing past our known valid ones
    // Use unsafe transmute to create an invalid ID (for testing only)
    let invalid_eq_proof_id = unsafe { std::mem::transmute::<u32, EqProofId>(99999) };
    let bad_sym_proof = EqProof::PSym { eq_pf: invalid_eq_proof_id };
    let bad_id = store.add_eq_proof(&bad_sym_proof);
    
    // We can store it but checking it should reveal the issue
    let bad = store.eq_proof(bad_id).expect("Bad proof should be stored");
    match bad {
        EqProof::PSym { eq_pf } => {
            // The referenced proof doesn't exist
            assert!(store.eq_proof(*eq_pf).is_none(), "Referenced proof should NOT exist");
        }
        _ => panic!("Expected symmetry proof"),
    }
}

#[test]
fn test_complex_manual_proof() {
    // Create a proof store and construct more complex proofs
    let mut store = ProofStore::default();
    
    // Build a more complex term structure: (Add (Mul 2 3) (Add 4 5))
    // First create the literals
    let lit2 = store.make_lit(egglog::ast::Literal::Int(2));
    let lit3 = store.make_lit(egglog::ast::Literal::Int(3));
    let lit4 = store.make_lit(egglog::ast::Literal::Int(4));
    let lit5 = store.make_lit(egglog::ast::Literal::Int(5));
    
    // Create Num wrappers for literals
    let num2 = store.make_app("Num".to_string(), vec![lit2]);
    let num3 = store.make_app("Num".to_string(), vec![lit3]);
    let num4 = store.make_app("Num".to_string(), vec![lit4]);
    let num5 = store.make_app("Num".to_string(), vec![lit5]);
    
    // Create complex terms
    let mul_2_3 = store.make_app("Mul".to_string(), vec![num2, num3]);
    let add_4_5 = store.make_app("Add".to_string(), vec![num4, num5]);
    let _add_complex = store.make_app("Add".to_string(), vec![mul_2_3, add_4_5]);
    
    // Create proofs for the base literals
    let num2_proof = TermProof::PFiat {
        desc: Rc::from("Literal 2"),
        term: num2,
    };
    let num2_id = store.add_term_proof(&num2_proof);
    
    let num3_proof = TermProof::PFiat {
        desc: Rc::from("Literal 3"),
        term: num3,
    };
    let _num3_id = store.add_term_proof(&num3_proof);
    
    // Create a congruence proof for the multiplication
    let mul_cong = TermProof::PCong(CongProof {
        pf_args_eq: vec![],  // No equality proofs
        pf_f_args_ok: num2_id,  // Base proof
        old_term: mul_2_3,
        new_term: mul_2_3,
        func: Arc::from("Mul"),
    });
    let mul_proof_id = store.add_term_proof(&mul_cong);
    
    // Create projection proofs to extract the arguments
    let proj_first_arg = TermProof::PProj {
        pf_f_args_ok: mul_proof_id,
        arg_idx: 0,
    };
    let proj_first_id = store.add_term_proof(&proj_first_arg);
    
    let proj_second_arg = TermProof::PProj {
        pf_f_args_ok: mul_proof_id,
        arg_idx: 1,
    };
    let proj_second_id = store.add_term_proof(&proj_second_arg);
    
    // Verify we can retrieve the projections
    match store.term_proof(proj_first_id) {
        Some(TermProof::PProj { arg_idx, .. }) => {
            assert_eq!(*arg_idx, 0, "First projection should be index 0");
        }
        _ => panic!("Expected projection proof"),
    }
    
    match store.term_proof(proj_second_id) {
        Some(TermProof::PProj { arg_idx, .. }) => {
            assert_eq!(*arg_idx, 1, "Second projection should be index 1");
        }
        _ => panic!("Expected projection proof"),
    }
    
    // Create a rule-based proof (simulating a rewrite rule application)
    // Simulate: (Mul x y) => (Mul y x) (commutativity)
    let mul_3_2 = store.make_app("Mul".to_string(), vec![num3, num2]);
    
    // Create a rule proof with proper structure
    // Note: PRule requires RuleVarBinding and body_pfs (premises)
    let rule_proof = TermProof::PRule {
        rule_name: Rc::from("mul-commute"),
        subst: vec![
            // Bind variable 'x' to Num 2
            RuleVarBinding {
                name: Arc::from("x"),
                term: num2,
                ty: ColumnTy::Id,  // Using Id type for now
            },
            // Bind variable 'y' to Num 3  
            RuleVarBinding {
                name: Arc::from("y"),
                term: num3,
                ty: ColumnTy::Id,  // Using Id type for now
            },
        ],
        body_pfs: vec![
            // The premise: (Mul x y) exists, proved by mul_proof_id
            Premise::TermOk(mul_proof_id),
        ],
        result: mul_3_2,
    };
    let rule_proof_id = store.add_term_proof(&rule_proof);
    
    // Create an equality proof showing mul_2_3 = mul_3_2
    let mul_eq = EqProof::PCong(CongProof {
        pf_args_eq: vec![],  // Would normally have proofs showing x=y, etc.
        pf_f_args_ok: mul_proof_id,
        old_term: mul_2_3,
        new_term: mul_3_2,
        func: Arc::from("Mul"),
    });
    let mul_eq_id = store.add_eq_proof(&mul_eq);
    
    // Create a chain of equalities using transitivity
    let refl1 = EqProof::PRefl {
        t: mul_2_3,
        t_ok_pf: mul_proof_id,
    };
    let refl1_id = store.add_eq_proof(&refl1);
    
    let refl2 = EqProof::PRefl {
        t: mul_3_2,
        t_ok_pf: rule_proof_id,
    };
    let _refl2_id = store.add_eq_proof(&refl2);
    
    // Chain equalities with transitivity
    let trans_chain = EqProof::PTrans {
        pfxy: refl1_id,
        pfyz: mul_eq_id,
    };
    let trans_chain_id = store.add_eq_proof(&trans_chain);
    
    // Verify the transitivity chain
    match store.eq_proof(trans_chain_id) {
        Some(EqProof::PTrans { .. }) => {
            // Chain exists
        }
        _ => panic!("Expected transitivity proof"),
    }
    
    // Verify the proof store contains all our proofs
    assert!(store.term_proof(num2_id).is_some());
    assert!(store.term_proof(mul_proof_id).is_some());
    assert!(store.term_proof(rule_proof_id).is_some());
    assert!(store.eq_proof(mul_eq_id).is_some());
    assert!(store.eq_proof(trans_chain_id).is_some());
}
