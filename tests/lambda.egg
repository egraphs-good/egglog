(datatype B (True) (False))
(datatype Term
    (Bool B)
    (Num i64)
    (Var String)
    (Add Term Term)
    (Eq Term Term)
    (App Term Term)
    (Lam String Term)
    (Let String Term Term)
    (Fix String Term Term)
    (If Term Term Term))

; All free variables are free,
; but some free variables are more free than others
; Freer variables will only contain variables
; that will affect the evaluation
; of the corresponding term
; e.g., x is free in x - x, but not freer in x - x
(relation freer (Term StringSet))
(rule ((= e (Var v)))
      ((free e v)))


;; START evals-to
(function evals-to (Term) Term)

(rule ((= e (Num n)))
      ((evals-to e e)))
(rule ((= e (Bool (True))))
      ((evals-to e e)))
(rule ((= e (Bool (False))))
      ((evals-to e e)))
(rule ((= e (Add a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      (union (evals-to e) (Num (+ va vb))))
(rule ((= e (Eq a b))
       (= (evals-to b) (evals-to a)))
      (union (evals-to e) (Bool (True))))
(rule ((= e (Eq a b))
       (= (Num va) (evals-to a))
       (= (Num vb) (evals-to b))
       (!= va vb))
      (union (evals-to e) (Bool (True))))
(rule ((= e (Eq a b))
       (= (Bool va) (evals-to a))
       (= (Bool vb) (evals-to b))
       (!= va vb)) ; TODO: if true and false are non-mergeable datatype, 
                   ; we should be able to do != over it
      ((union (evals-to e) (Bool (False)))))
;; END evals-to

; if-true
(rewrite (If (Bool (True)) then else) then)
; if-false
(rewrite (If (Bool (False)) then else) else)
; if-elim
(rule ((= term (If (Eq (Var x) e) then else)))
      ((Let x e then)
       (Let x e else)))
(rewrite (If (Eq (Var x) e) then else) else
    :when ((= (let x e then) (let x e else))))

; add-comm
(rewrite (Add a b) (Add b a))
; add-assoc
(rewrite (Add (Add a b) c) (Add a (Add b c)))
; eq-comm
(rewrite (Eq a b) (Eq b a))

; fix
(rewrite (Fix v e) (Let v (Fix v e) e))
; beta
(rewrite (App (Lam v body) e) (Let v e body))
; let-app
(rewrite (Let v e (App a b)) (App (Let v e a) (Let v e b)))
; let-add
(rewrite (Let v e (Add a b)) (Add (Let v e a) (Let v e b)))
; let-eq
(rewrite (Let v e (Eq a b)) (Eq (Let v e a) (Let v e b)))
; let-const
(rewrite (Let v e c) c :when ((= const (evals-to c))))
; let-if
(rewrite (Let v e (If cond then else)) 
         (If (Let v e cond) (Let v e then) (Let v e else)))
; let-var-same
(rewrite (Let v1 e (Var v1)) e)
; let-var-diff
(rewrite (Let v1 e (Var v2)) (Var v2) :when (!= v1 v2))
; let-lam-same
(rewrite (Let v1 e (Lam v1 body)) (Lam v1 body))
; let-lam-diff
(rewrite (Let v1 e (Lam v2 body)) TODO)
