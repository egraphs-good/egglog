; Algorithm W for HM type system
; TODO: how does our algo differ from Prolog?
; How does one write this program in Prolog?
; TODO: Does the current algorithm work if the e-graph contains more than one expr?

;;;;;;;;;;;;;;;;;;;;;;
;; Exprs and Types
;;;;;;;;;;;;;;;;;;;;;;

(datatype Ident)
(datatype Expr)
(datatype Type)
(datatype QualifiedVs)
(datatype Scheme)
(datatype Ctx)
(sort StringSet (Map Ident i64))

(function FreshFromSubst (QualifiedVs String) Ident)
(function FreshFromLam (Expr Ctx String Expr) Ident)
(function FromString (String) Ident)
 
(function Var (String) Expr)
(function App (Expr Expr) Expr)
(function Abs (String Expr) Expr)
(function Let (String Expr Expr) Expr)
(function Num (i64) Expr)
(function True () Expr)
(function False () Expr)
(function Unit () Expr)

(function TVar (Ident) Type)
(function TArr (Type Type) Type)
(function TInt () Type)
(function TBool () Type)
(function TUnit () Type)

;;;;;;;;;;;;;;;;;;;;;;
;; Free variables
;;;;;;;;;;;;;;;;;;;;;;

; (fv x y) means y is a free variable of x
(relation ftv (Type Ident))

; ftv(a) = a
; TODO: when the TVar is resolved, it is still not removed and therefore will occur in the ftv set...
; <del>we can potentially work around this by having an analysis: Unresolved < Resolved </del>
; essentially, the set of free variable is not monotonic across iteration
(rule (
  (= t (TVar x))
)(
  (ftv t x)
))

; ftv(t1 -> t2) = ftv(t1) + ftv(t2)
(rule (
  (= t (TArr t1 t2))
  (ftv t1 x)
)(
  (ftv t x)
))

(rule (
  (= t (TArr t1 t2))
  (ftv t2 x)
)(
  (ftv t x)
))

;;;;;;;;;;;;;;;;;;;;;;
;; Scheme and Context
;;;;;;;;;;;;;;;;;;;;;;

(function EmptyVSet () QualifiedVs)
(function FromFV (Type) QualifiedVs)
(function SetDiff (QualifiedVs StringSet) QualifiedVs)

;; TODO: add demand so containsStr is not instantiated for every context
;; TODO: needs recursive type definition
(relation containsStr (QualifiedVs Ident))

(rule ((= s (FromFV t))
       (ftv t x))
      ((containsStr s x)))

(rule ((= s (SetDiff a b))
       (containsStr a x)
       (not-contains b x))
      ((containsStr s x)))

; Scheme := forall xs. t
(function Forall (QualifiedVs Type) Scheme)

; A context is a map from vars to schemes

(function Nil () Ctx)
(function Cons (String Scheme Ctx) Ctx)

;; TODO: can't do unit right now
;; (sort StringSet (Map String Unit))

(relation keySet (Ctx StringSet))
(rule ((= c (Nil))) (keySet c (empty)))
(rule ((= c (Cons x s n))
       (keySet n fvs)) 
      ((keySet c (insert x 1 fvs))))

(function lookup (Ctx String) Scheme)

(rewrite (lookup (Cons x s tl) x) s)

(rule (
  (= t (lookup (Cons y s tl) x))
  (!= x y)
)(
  (union t (lookup tl x))
))

(relation haskey (Ctx String))
(relation haskey-demand (Ctx Ctx))
(rule (
  (haskey-demand target-ctx current-ctx)
  (= current-ctx (Cons x s next-ctx))
)(
  (haskey target-ctx x)
  (haskey-demand target-ctx next-ctx)
))

;;;;;;;;;;;;;;;;;;;;;;
;; Generalization and Instantiation
;;;;;;;;;;;;;;;;;;;;;;

(function generalize (Ctx Type) Scheme)
(function instantiate (Scheme) Type)

;; TODO: this does not work
;; (rewrite (generalize ctx t) 
;;          (Forall (SetDiff (FromFV t) 
;;                           key-set)
;;                   t)
;;          :when (keySet ctx key-set)
;;          )
(rule ((= o (generalize ctx t))
       (keySet ctx key-set))
      ((Forall (SetDiff (FromFV t) 
                        key-set)
                t)))

(function subst-fresh (QualifiedVs Type) Type)

(rewrite (subst-fresh vs (TInt)) (TInt))
(rewrite (subst-fresh vs (TBool)) (TBool))
(rewrite (subst-fresh vs (TUnit)) (TUnit))
(rewrite (subst-fresh vs (TArr fr to)) (TArr (subst vs fr) (subst vs to)))
(rule ((= otype (subst-fresh vs (TVar s)))
       (containsStr vs s))
      ((union otype (TVar (FreshFromSubst vs s)))))

(rewrite (instantiate (Forall vs t))
         (subst-fresh vs t))


;;;;;;;;;;;;;;;;;;;;;;
;; Injectivity
;;;;;;;;;;;;;;;;;;;;;;

(rule ( ; injectivity of ->
  (= (TArr fr1 to1) (TArr fr2 to2))
)(
  (union fr1 fr2) 
  (union to1 to2)
))

;;;;;;;;;;;;;;;;;;;;;;
;; Type inference
;;;;;;;;;;;;;;;;;;;;;;

; ctx |- expr : type
(function typeof (Ctx Expr) Type)

;; Basic types (TInt, TBool, TUnit)
(rewrite (typeof ctx (Num x)) (TInt))
(rewrite (typeof ctx (True)) (TBool))
(rewrite (typeof ctx (False)) (TBool))
(rewrite (typeof ctx (Unit)) (TUnit))

; sc = lookup(ctx, x)
; t = instantiate(sc)
; ---------------
; ctx |- x : t
(rewrite (typeof ctx (Var x))
         (instantiate (lookup ctx x)))

(rule (
    (= t (typeof ctx (Abs x e)))
)(
    ;; (let tv (TVar (FreshFromLam ctx x e)))
    ;; (let te (typeof (Cons x (Forall (EmptyVSet) tv) ctx) 
    ;;               e))
    ;; (union t (TArr tv te))
    ;; unfolds to
    (union 
      t 
      (TArr (TVar (FreshFromLam ctx x e)) 
            (typeof (Cons x (Forall (EmptyVSet) 
                                    (TVar (FreshFromLam ctx x e))) 
                          ctx) 
                  e)))
))

(rule (
    (= to (typeof ctx (App e1 e2)))
)(
    (union (typeof ctx e1) 
           (TArr (typeof ctx e2) to))
))

(rewrite (typeof ctx (Let x e1 e2))
         (typeof (Cons x (generalize ctx (typeof ctx e1)) 
                       ctx)
                 e2))

