;;;;;;;;;;;;;;;;;;;;;;
;; Exprs and Types
;;;;;;;;;;;;;;;;;;;;;;

(datatype Ident)
(datatype Expr)
(datatype Type)
(datatype QualifiedVs)
(datatype Scheme)
(datatype Ctx)
;; TODO: can't do unit right now
;; (sort QualifiedVs (Map String Unit))
(sort QualifiedVs (Map Ident i64))

(function FreshFromSubst (QualifiedVs String) Ident)
(function FreshFromLam (Expr Ctx String Expr) Ident)
(function FromString (String) Ident)
 
(function Var (String) Expr)
(function App (Expr Expr) Expr)
(function Abs (String Expr) Expr)
(function Let (String Expr Expr) Expr)
(function Num (i64) Expr)
(function True () Expr)
(function False () Expr)
(function Unit () Expr)

(function TVar (Ident) Type)
(function TArr (Type Type) Type)
(function TInt () Type)
(function TBool () Type)
(function TUnit () Type)

(function Forall (QualifiedVs Type) Scheme)
(function Nil () Ctx)
(function Cons (String Scheme Ctx) Ctx)

(relation keySet (Ctx QualifiedVs))
(relation fvSet (Type QualifiedVs))

;;;;;;;;;;;;;;;;;;;;;;
;; Scheme and Context
;;;;;;;;;;;;;;;;;;;;;;

(rule ((= c (Nil))) (keySet c (empty)))
(rule ((= c (Cons x s n))
       (keySet n fvs)) 
      ((keySet c (insert x 1 fvs))))

;; TODO: rewrite lookup to use native sets
(function lookup (Ctx String) Scheme)
(rewrite (lookup (Cons x s tl) x) s)
(rule (
  (= t (lookup (Cons y s tl) x))
  (!= x y)
)(
  (union t (lookup tl x))
))

;;;;;;;;;;;;;;;;;;;;;;
;; Generalization and Instantiation
;;;;;;;;;;;;;;;;;;;;;;

(function generalize (Ctx Type) Scheme)
(function instantiate (Scheme) Type)

(rewrite (generalize ctx t) 
         (Forall (set-diff fv-set key-set) t)
         :when ((keySet ctx key-set) (fvSet t fv-set)))

(function subst-fresh (QualifiedVs Type) Type)
;; the type produced by (subst-fresh qvs type) has these free type variables
(relation substFvSet (QualifiedVs Type QualifiedVs))

;; (rewrite (subst-fresh vs (TInt)) (TInt))
(rule ((= otype (subst-fresh vs (TInt))))
      ((union otype (TInt))
       (substFvSet vs (TInt) (empty))))
;; (rewrite (subst-fresh vs (TBool)) (TBool))
(rule ((= otype (subst-fresh vs (TBool))))
      ((union otype (TBool))
       (substFvSet vs (TBool) (empty))))
;; (rewrite (subst-fresh vs (TUnit)) (TUnit))
(rule ((= otype (subst-fresh vs (TUnit))))
      ((union otype (TUnit))
       (substFvSet vs (TUnit) (empty))))

(rewrite (subst-fresh vs (TArr fr to)) (TArr (subst vs fr) (subst vs to)))
(rule ((= otype (subst-fresh vs (TArr fr to)))
       (substFvSet vs fr qvs1)
       (substFvSet vs to qvs2))
      ((substFvSet vs (TArr fr to) (set-union qvs1 qvs2))))

(rule ((= otype (subst-fresh vs (TVar s)))
       (= unused (get vs s)))
      ((union otype (TVar (FreshFromSubst vs s)))
       (substFvSet vs (TVar s) (insert (empty) (FreshFromSubst vs s) 1))))

(rule ((= otype (subst-fresh vs (TVar s)))
       (not-contains vs s))
      ((union otype (TVar s))
       (substFvSet vs (TVar s) (insert (empty) (TVar s)))))

(rewrite (instantiate (Forall vs t))
         (subst-fresh vs t))

;;;;;;;;;;;;;;;;;;;;;;
;; Injectivity
;;;;;;;;;;;;;;;;;;;;;;

(rule ((= (TArr fr1 to1) (TArr fr2 to2)))
      ((union fr1 fr2) 
       (union to1 to2)))

;;;;;;;;;;;;;;;;;;;;;;
;; Type inference
;;;;;;;;;;;;;;;;;;;;;;

; ctx |- expr : type
(function typeof (Ctx Expr) Type)

;; Basic types (TInt, TBool, TUnit)
(rewrite (typeof ctx (Num x)) (TInt))
(rewrite (typeof ctx (True)) (TBool))
(rewrite (typeof ctx (False)) (TBool))
(rewrite (typeof ctx (Unit)) (TUnit))

(rule () ((fvSet (TInt) (empty))
          (fvSet (TBool) (empty))
          (fvSet (TUnit) (empty))))

; sc = lookup(ctx, x)
; t = instantiate(sc)
; ---------------
; ctx |- x : t
(rewrite (typeof ctx (Var x))
         (instantiate (lookup ctx x)))
(rule ((= otype (instantiate (Forall vs t)))
       (substFvSet vs t ftv))
      ((fvSet otype ftv)))

(rule (
    (= t (typeof ctx (Abs x e)))
)(
    ;; (let tv (TVar (FreshFromLam ctx x e)))
    ;; (let te (typeof (Cons x (Forall (empty) tv) ctx) 
    ;;               e))
    ;; (union t (TArr tv te))
    ;; unfolds to
    (union 
      t 
      (TArr (TVar (FreshFromLam ctx x e)) 
            (typeof (Cons x (Forall (empty) 
                                    (TVar (FreshFromLam ctx x e))) 
                          ctx) 
                  e)))
))
(rule ((= otype (typeof ctx (Abs x e)))
       (= t (typeof (Cons x (Forall (empty) (TVar (FreshFromLam ctx x e))) ctx) e)) 
       (fvSet t fv-set))
      ((fvSet otype 
              (insert fv-set (TVar (FreshFromLam ctx x e)) 1))))


(rule (
    (= to (typeof ctx (App e1 e2)))
)(
    (union (typeof ctx e1) 
           (TArr (typeof ctx e2) to))
))

;; TODO: also note that the set of FVs can be recalculated from different places
;; and they must be equivalent
(rule (
    (= otype (typeof ctx (App e1 e2)))
    (fvSet )
)(

))

(rewrite (typeof ctx (Let x e1 e2))
         (typeof (Cons x (generalize ctx (typeof ctx e1)) 
                       ctx)
                 e2))
