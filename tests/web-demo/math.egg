; Converted from the egg demo at
; https://github.com/egraphs-good/egg/blob/fb6167957beb5dd7c784121459e08ebd1ccb1a00/tests/math.rs

(datatype Math
    (Diff Math Math :cost 100)
    (Integral Math Math :cost 100)

    (Add Math Math)
    (Sub Math Math)
    (Mul Math Math)
    (Div Math Math)
    (Pow Math Math)
    (Ln Math)
    (Sqrt Math)

    (Sin Math)
    (Cos Math)

    (Const f64)
    (Var String))

(relation MathU (Math))
(rule ((= e (Diff x y))) ((MathU e)))
(rule ((= e (Integral x y))) ((MathU e)))
(rule ((= e (Add x y))) ((MathU e)))
(rule ((= e (Sub x y))) ((MathU e)))
(rule ((= e (Mul x y))) ((MathU e)))
(rule ((= e (Div x y))) ((MathU e)))
(rule ((= e (Pow x y))) ((MathU e)))
(rule ((= e (Ln x))) ((MathU e)))
(rule ((= e (Sqrt x))) ((MathU e)))
(rule ((= e (Sin x))) ((MathU e)))
(rule ((= e (Cos x))) ((MathU e)))
(rule ((= e (Const x))) ((MathU e)))
(rule ((= e (Var x))) ((MathU e)))

; same as constant fold in egg
(rewrite (Add (Const a) (Const b)) (Const (+ a b)))
(rewrite (Sub (Const a) (Const b)) (Const (- a b)))
(rewrite (Mul (Const a) (Const b)) (Const (* a b)))
(rewrite (Div (Const a) (Const b)) (Const (/ a b)) :when ((!= b 0.0)))

(relation is-sym (Math))
(rule ((= e (Var s))) ((is-sym e)))

(relation is-not-zero (Math))
(rule ((= x (Const vx))
       (!= vx 0.0))
      ((is-not-zero x)))

(relation is-const-or-distinct-var-demand (Math String))
(relation is-const-or-distinct-var (Math String))
(rule ((is-const-or-distinct-var-demand (Var w) v)
       (!= v w))
      ((is-const-or-distinct-var (Var w) v)))
(rule ((is-const-or-distinct-var-demand (Const c) v))
      ((is-const-or-distinct-var (Const c) v)))

(rewrite (Add a b) (Add b a))
(rewrite (Mul a b) (Mul b a))
(rewrite (Add a (Add b c)) (Add (Add a b) c))
(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))

(rewrite (Sub a b) (Add a (Mul (Const -1.0) b)))
(rewrite (Div a b) (Mul a (Pow b (Const -1.0))) :when ((is-not-zero b)))

(rewrite (Add a (Const 0.0)) a)
(rewrite (Mul a (Const 0.0)) (Const 0.0))
(rewrite (Mul a (Const 1.0)) a)

;; NOTE: these two rules are different from math.rs, as math.rs does pruning
(rule ((MathU a) (!= a (Const 0.0))) ((union a (Add a (Const 0.0)))))
(rule ((MathU a) (!= a (Const 1.0))) ((union a (Mul a (Const 1.0)))))

(rewrite (Sub a a) (Const 0.0))
(rewrite (Div a a) (Const 1.0) :when ((is-not-zero a)))

(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))
(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))

(rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)))
(rewrite (Pow x (Const 0.0)) (Const 1.0) :when ((is-not-zero x)))
(rewrite (Pow x (Const 1.0)) x)
(rewrite (Pow x (Const 2.0)) (Mul x x))
(rewrite (Pow x (Const -1.0)) (Div (Const 1.0) x) :when ((is-not-zero x)))
(rewrite (Mul x (Div (Const 1.0) x)) (Const 1.0) :when ((is-not-zero x)))

(rewrite (Diff (Var x) (Var x)) (Const 1.0))
(rule ((Diff (Var x) c))
      ((is-const-or-distinct-var-demand c x)))
(rewrite (Diff (Var x) c) (Const 0.0) :when ((is-const-or-distinct-var c x)))

(rewrite (Diff x (Add a b)) (Add (Diff x a) (Diff x b)))
(rewrite (Diff x (Mul a b)) (Add (Mul a (Diff x b)) (Mul b (Diff x a))))

(rewrite (Diff x (Sin x)) (Cos x))
(rewrite (Diff x (Cos x)) (Mul (Const -1.0) (Sin x)))

(rewrite (Diff x (Ln x)) (Div (Const 1.0) x) :when ((is-not-zero x)))

(rewrite (Diff x (Pow f g))
         (Mul (Pow f g)
              (Add (Mul (Diff x f) (Div g f))
                   (Mul (Diff x g) (Ln f))))
         :when ((is-not-zero f)
                (is-not-zero g)))

(rewrite (Integral (Const 1.0) x) x)
(rewrite (Integral (Pow x (Const c)) x)
         (Div (Pow x (Add (Const c) (Const 1.0))) (Add (Const c) (Const 1.0))))
(rewrite (Integral (Cos x) x) (Sin x))
(rewrite (Integral (Sin x) x) (Mul (Const -1.0) (Cos x)))
(rewrite (Integral (Add f g) x) (Add (Integral f x) (Integral g x)))
(rewrite (Integral (Sub f g) x) (Sub (Integral f x) (Integral g x)))
(rewrite (Integral (Mul a b) x)
         (Sub (Mul a (Integral b x))
              (Integral (Mul (Diff x a) (Integral b x)) x)))


(let start-expr2 (Add (Const 1.0)
                        (Sub (Var "a")
                             (Mul (Sub (Const 2.0)
                                       (Const 1.0))
                                  (Var "a")))))

(run 6)

(let end-expr2 (Const 1.0))

(check (= start-expr2 end-expr2))

(extract start-expr2)
