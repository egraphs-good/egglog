(datatype Term (Term String))
(datatype NonTerm (NonTerm String))

(datatype Tree (NT String Tree Tree)
                  (T String String))

(function getString (i64) String)

(relation Prod (NonTerm NonTerm NonTerm))
(relation End (NonTerm String))


; let P[n,n,r] be an array of booleans. Initialize all elements of P to false.
; let back[n,n,r] be an array of lists of backpointing triples. 
; Initialize all elements of back to the empty list.

; for each s = 1 to n
;     for each unit production Rv → as
;         set P[1,s,v] = true

;; for each l = 2 to n -- Length of span
;;     for each s = 1 to n-l+1 -- Start of span
;;         for each p = 1 to l-1 -- Partition of span
;;             for each production Ra    → Rb Rc
;;                 if P[p,s,b] and P[l-p,s+p,c] then
;;                     set P[l,s,a] = true, 
;;                     append <p,b,c> to back[l,s,a]

; [p ... s][l-p ... s+p]
; [l         s]

(relation P (i64 i64 NonTerm))
(function B (i64 i64 NonTerm) Tree :cost 1000)
; (relation B (i64 i64 NonTerm Tree))

(rule ((End (NonTerm a) s)
       (= s (getString pos)))
      ((P 1 pos (NonTerm a))
       (set (B 1 pos (NonTerm a)) (T a s))
      )) 

(rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c)) ;; a -> bc
       (P p1 s (NonTerm b))
       (P p2 (+ s p1) (NonTerm c)))
      ((P (+ p1 p2) s (NonTerm a))))

; (rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c))
;        (=f (B p1 s (NonTerm b)))
;        (=f (B p2 (+ s p1) (NonTerm c))))
;       ( (set (B (+ p1 p2) s (NonTerm a)) (NT a (B p1 s (NonTerm b)) (B p2 (+ s p1) (NonTerm c)) )))
; )

(rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c))
       (= f1 (B p1 s (NonTerm b)))
       (= f2 (B p2 (+ s p1) (NonTerm c))))
      ((set (B (+ p1 p2) s (NonTerm a)) 
       (NT a f1 f2))))
       ;;(NT a  (B p1 s (NonTerm b)) (B p2 (+ s p1) (NonTerm c))))))


(push)

(set (getString 7) "fork")
(set (getString 6) "a")
(set (getString 5) "with")
(set (getString 4) "fish")
(set (getString 3) "a")
(set (getString 2) "eats")
(set (getString 1) "she")

; (set (getString 1) "she")
; (set (getString 2) "eats")
; (set (getString 3) "a")
; (set (getString 4) "fish")
; (set (getString 5) "with")
; (set (getString 6) "a")
; (set (getString 7) "fork")


(Prod (NonTerm "S") (NonTerm "NP") (NonTerm "VP"))
(Prod (NonTerm "VP") (NonTerm "VP") (NonTerm "PP"))
(Prod (NonTerm "VP") (NonTerm "V") (NonTerm "NP"))
(End (NonTerm "VP")  "eats")
(Prod (NonTerm "PP") (NonTerm "P") (NonTerm "NP"))
(Prod (NonTerm "NP") (NonTerm "DET") (NonTerm "N"))
(End (NonTerm "NP") "she")
(End (NonTerm "V") "eats")
(End (NonTerm "P") "with")
(End (NonTerm "N") "fish")
(End (NonTerm "N") "fork")
(End (NonTerm "DET") "a")


(define test1 (B 7 1 (NonTerm "S")):cost 1000)

(run 100)

(check (P 7 1 (NonTerm "S")))

(extract test1)
(print test1)

(pop)

(push)

(Prod (NonTerm "S") (NonTerm "A") (NonTerm "B"))
(Prod (NonTerm "S") (NonTerm "B") (NonTerm "C"))
(Prod (NonTerm "A") (NonTerm "B") (NonTerm "A"))
(End (NonTerm "A") "a")
(Prod (NonTerm "B") (NonTerm "C") (NonTerm "C"))
(End (NonTerm "B") "b")
(Prod (NonTerm "C") (NonTerm "A") (NonTerm "B"))
(End (NonTerm "C") "a")

(push)

(set (getString 1) "a")
(set (getString 2) "b")
(set (getString 3) "a")
(set (getString 4) "a")
(set (getString 5) "b")

(run 100)
(check (P 5 1 (NonTerm "S")))
(define test2 (B 5 1 (NonTerm "S")):cost 1000)
(extract:variants 10  test2)
(print test2)

(pop)

(push)

(set (getString 1) "a")
(set (getString 2) "a")
(set (getString 3) "a")
(set (getString 4) "a")
(set (getString 5) "a")

(run 100)
(check (P 5 1 (NonTerm "S")))
(define test3 (B 5 1 (NonTerm "S")):cost 1000)
(extract test3)
(print test3) 

(pop)
(pop)

(push)

; more random
(Prod (NonTerm "B") (NonTerm "C") (NonTerm "C"))
(End (NonTerm "C") "a")
(Prod (NonTerm "S") (NonTerm "B") (NonTerm "C"))
(End (NonTerm "A") "a")
(End (NonTerm "B") "b")
(Prod (NonTerm "A") (NonTerm "B") (NonTerm "A"))
(Prod (NonTerm "C") (NonTerm "A") (NonTerm "B"))
(Prod (NonTerm "S") (NonTerm "A") (NonTerm "B"))


(set (getString 5) "a")
(set (getString 3) "a")
(set (getString 4) "a")
(set (getString 1) "a")
(set (getString 2) "a")


(run 100)
(check (P 5 1 (NonTerm "S")))
(define test4 (B 5 1 (NonTerm "S")):cost 1000)
(extract test4)
(print test4) ; cannot find the the other parse tree
