(datatype Var (V String))
(datatype Val (I i64) (True) (False))
(datatype Loc (L i64))
(datatype Exp
    (Add Var Var)
    (Eq Var Var)
    (Var Var)
    (Const Val))
(datatype ProgStmt
    (Ass Var Exp)
    (If Var Loc Loc)
    (Goto Loc)
    (Call Var)
    (End))
(function Prog (Loc) ProgStmt)


;; we need the following lattice:
;;         top
;;   1 2 3 4 5 6 ...
;;         bot
(function const-prop (Loc Var) Val :merge (I 1000) :default (I 1000))

;;;;;;;;;;;;;;;;
;; ASS Case
;;;;;;;;;;;;;;;;

; propagate x = k
(rule (
    (= (Prog (L li)) (Ass x (Const k)))
    (= li+1 (+ li 1))
)(
    (set (const-prop (L li+1) x) k)
))

; propagate x = a + b (non-constant)
(rule (
    (= (Prog (L li)) (Ass x (Add v1 v2)))
    (= (I i1) (const-prop l v1))
    (= (I i2) (const-prop l v2))
    (= val (+ i1 i2))
    (> val 1000)
    (= li+1 (+ li 1))
)(
    (set (const-prop (L li+1) x) (I 1000))
))

;; ; propagate other vars
(rule (
    (= (Prog (L li)) (Ass (V x) e))
    (= val (const-prop (L li) (V y)))
    (= li+1 (+ li 1))
    (!= x y)
)(
    (set (const-prop (L li+1) (V y)) val)
))

;; ; replace x = a + b (constant)
(rule (
    (= p (Ass x (Add v1 v2)))
    (= p (Prog l)) 
    (= (I i1) (const-prop l v1))
    (= (I i2) (const-prop l v2))
    (= val (+ i1 i2))
    (< val 1000)
)(
    (union p (Ass x (Const (I val))))
))

;;;;;;;;;;;;;;;;
;; CALL CASE
;;;;;;;;;;;;;;;;
(rule (
    (= p (Call f))
    (= p (Prog l))
    (= val (const-prop (L li) x))
    (= li+1 (+ li 1))
)(
    (set (const-prop (L li+1) x) val)
))

;;;;;;;;;;;;;;;;
;; IF CASE
;;;;;;;;;;;;;;;;

; replace if true
(rule (
    (= p (Prog l))
    (= p (If b l1 l2))
    (= (True) (const-prop l b))
)(
    (union p (Goto l1))
))

;; ; replace if false
(rule (
    (= p (Prog l))
    (= p (If b l1 l2))
    (= (False) (const-prop l b))
)(
    (union p (Goto l2))
))

;; ; propagate vars
;; ; TODO: we should test if b is neither true nor false
;; ; this requires Val being a lattice
(rewrite (const-prop l1 x) val
    :when ((= (Prog (L li)) (If b l1 l2))
           (= val (const-prop (L li) x))))

(rewrite (const-prop l2 x) val
    :when ((= (Prog (L li)) (If b l1 l2))
           (= val (const-prop (L li) x))))

;;;;;;;;;;;;;;;;
;; GOTO CASE
;;;;;;;;;;;;;;;;

; propagate vars
;; TODO name conflict with last one
(rewrite (const-prop l2-avoid-name-conflict x) val
    :when ((= (Prog l1) (Goto l2-avoid-name-conflict))
           (= val (const-prop l1  x))))

;;;;;;;;;;;;;;;;
;; TEST
;;;;;;;;;;;;;;;;

(union (Prog (L 1)) (Ass (V "ten") (Const (I 10))))
(union (Prog (L 2)) (Ass (V "one") (Const (I 1))))
(union (Prog (L 3)) (Ass (V "zero") (Const (I 0))))
; x := 10
(union (Prog (L 4)) (Ass (V "x") (Const (I 10))))
; while (...) {
(union (Prog (L 5)) (If (V "b") (L 6) (L 13)))
;     if (x == 10) {
(union (Prog (L 6)) (Ass (V "cond") (Eq (V "x")) (V "ten")))
(union (Prog (L 7)) (If (V "cond") (L 8) (L 10)))
;         DoSomething();
(union (Prog (L 8)) (Call (V "DoSomething")))
;     }
(union (Prog (L 9)) (Goto (L 12)))
;     else {
;         DoSomething();
(union (Prog (L 10)) (Call (V "DoSomethingElse")))
;         x := x + 1;
(union (Prog (L 11)) (Ass (V "x") (Add (V "x") (V "one"))))
;     }
(union (Prog (L 12)) (Goto (L 5)))
; y := x
(union (Prog (L 13)) (Ass (V "y") (Add (V "x") (V "zero"))))
(union (Prog (L 14)) (End))


(run 10)

(check (= (const-prop (L 14) (V "y")) (I 10)))