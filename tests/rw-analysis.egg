; Top means the value does not exist
(datatype Val (Top) (I i64) (True) (False))

(function merge-val (Val Val) Val)

(rewrite (merge-val (Top) x) (Top))
(rewrite (merge-val x (Top)) (Top))
(rewrite (merge-val (True)  (False)) (Top))
(rewrite (merge-val (True)  (I x))   (Top))
(rewrite (merge-val (False) (True))  (Top))
(rewrite (merge-val (False) (I x))   (Top))
(rewrite (merge-val (I x) (I y)) (Top) :when ((!= x y)))
(rewrite (merge-val x x) x)

(function add-val (Val Val) Val)

(rewrite (add-val (Top) x) (Top))
(rewrite (add-val x (Top)) (Top))
(rewrite (add-val (True) x) (Top))
(rewrite (add-val (False) x) (Top))
(rewrite (add-val x (True)) (Top))
(rewrite (add-val x (False)) (Top))
(rewrite (add-val (I x) (I y)) (I (+ x y)))

(datatype Var (V String))
(datatype Loc (L i64))
(datatype Exp
    (Add Var Var)
    (Eq Var Var)
    (Var Var)
    (Const Val))
(datatype ProgStmt
    (Ass Var Exp)
    (If Var Loc Loc)
    (Goto Loc)
    (Call Var)
    (End))
(function Prog (Loc) ProgStmt)

(function const-prop (Loc Var) Val :merge (merge-val old new))

;;;;;;;;;;;;;;;;
;; ASS Case
;;;;;;;;;;;;;;;;

; propagate x = k
(rule (
    (= (Prog (L li)) (Ass x (Const k)))
)(
    (set (const-prop (L (+ li 1)) x) k)
))

; propagate x = a + b (non-constant)
(rule (
    (= (Prog l) (Ass x (Add x1 x2)))
    (= l (L li))
)(
    (set (const-prop (L (+ li 1)) x) 
         (add-val (const-prop l x1) (const-prop l x2)))
))

; propagate other vars
(rule (
    (= (Prog (L li)) (Ass (V x) e))
    (= val (const-prop (L li) (V y)))
    (!= x y)
)(
    (set (const-prop (L (+ li 1)) (V y)) val)
))

; replace x = a + b (constant)
; TODO: usually because add-val is not computed on-demand, 
; we have to demand-transform the rule
; however, because the rule for propagate x = a + b (non-constant)
; populates the add-val already, we don't need to do it here.
(rule (
    (= p (Ass x (Add x1 x2)))
    (= p (Prog l))
    (= (I val) (add-val (const-prop l x1)
                        (const-prop l x2)))
)(
    (union p (Ass x (Const (I val))))
))

;;;;;;;;;;;;;;;;
;; CALL CASE
;;;;;;;;;;;;;;;;
(rule (
    (= p (Call f))
    (= p (Prog l))
    (= val (const-prop (L li) x))
)(
    (set (const-prop (L (+ li 1)) x) val)
))

;;;;;;;;;;;;;;;;
;; IF CASE
;;;;;;;;;;;;;;;;

; replace if true
(rule (
    (= p (Prog l))
    (= p (If b l1 l2))
    (= (True) (const-prop l b))
)(
    (union p (Goto l1))
))

;; ; replace if false
(rule (
    (= p (Prog l))
    (= p (If b l1 l2))
    (= (False) (const-prop l b))
)(
    (union p (Goto l2))
))

;; ; propagate vars
;; ; TODO: we should test if b is neither true nor false
;; ; this requires Val being a lattice
(rewrite (const-prop l1 x) val
    :when ((= (Prog (L li)) (If b l1 l2))
           (= val (const-prop (L li) x))))

(rewrite (const-prop l2 x) val
    :when ((= (Prog (L li)) (If b l1 l2))
           (= val (const-prop (L li) x))))

;;;;;;;;;;;;;;;;
;; GOTO CASE
;;;;;;;;;;;;;;;;

; propagate vars
;; TODO name conflict with last one
(rewrite (const-prop l2-avoid-name-conflict x) val
    :when ((= (Prog l1) (Goto l2-avoid-name-conflict))
           (= val (const-prop l1  x))))

;;;;;;;;;;;;;;;;
;; TEST
;;;;;;;;;;;;;;;;

(union (Prog (L 1)) (Ass (V "ten") (Const (I 10))))
(union (Prog (L 2)) (Ass (V "one") (Const (I 1))))
(union (Prog (L 3)) (Ass (V "zero") (Const (I 0))))
; x := 10
(union (Prog (L 4)) (Ass (V "x") (Const (I 10))))
; while (...) {
(union (Prog (L 5)) (If (V "b") (L 6) (L 13)))
;     if (x == 10) {
(union (Prog (L 6)) (Ass (V "cond") (Eq (V "x")) (V "ten")))
(union (Prog (L 7)) (If (V "cond") (L 8) (L 10)))
;         DoSomething();
(union (Prog (L 8)) (Call (V "DoSomething")))
;     }
(union (Prog (L 9)) (Goto (L 12)))
;     else {
;         DoSomething();
(union (Prog (L 10)) (Call (V "DoSomethingElse")))
;         x := x + 1;
(union (Prog (L 11)) (Ass (V "x") (Add (V "x") (V "one"))))
;     }
(union (Prog (L 12)) (Goto (L 5)))
; y := x
(union (Prog (L 13)) (Ass (V "y") (Add (V "x") (V "zero"))))
(union (Prog (L 14)) (End))

(run 20)

(check (= (const-prop (L 14) (V "y")) (I 10)))
