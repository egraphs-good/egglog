; unstable-fresh! sugar tests with multiple sorts in the query to exercise
; column inference across heterogeneous subexpressions.

(datatype Math
  (Let Math Math)
  (Var String)
  (I i64)
  (S String))


; Seed facts so rules have matches
(let seed_x0 (Let (Var "x") (I 0)))
(let seed_y0 (Let (Var "y") (I 0)))
(let seed_x1 (Let (Var "x") (I 1)))

; 1) Difference only in a String-typed subexpression inside the query
;    (Var "x") vs (Var "y"). If String subexpressions are included,
;    these fresh values should be different.
(relation rx (Math))
(relation ry (Math))
(rule ((Let (Var "x") (I 0)))
      ((let a (unstable-fresh! Math))
       (set (rx a) ())))
(rule ((Let (Var "y") (I 0)))
      ((let b (unstable-fresh! Math))
       (set (ry b) ())))
(relation str_pair (Math Math))
(rule ((rx x) (ry y)) ((set (str_pair x y) ())))
; No pair should have equal components if the String literal participates
(fail (check (str_pair z z)))

; 2) Difference only in an i64-typed subexpression inside the query
;    (I 0) vs (I 1). If i64 subexpressions are included, these fresh
;    values should be different.
(relation r0 (Math))
(relation r1 (Math))
(rule ((Let (Var "x") (I 0)))
      ((let a (unstable-fresh! Math))
       (set (r0 a) ())))
(rule ((Let (Var "x") (I 1)))
      ((let b (unstable-fresh! Math))
       (set (r1 b) ())))
(relation i64_pair (Math Math))
(rule ((r0 x) (r1 y)) ((set (i64_pair x y) ())))
(fail (check (i64_pair z z)))

; 3) Difference in an additional String-typed fact that is not a subterm of
;    the matched Let node. Column inference must include subexpressions from
;    all query facts, not just the main pattern.
(relation rfoo (Math))
(relation rbar (Math))
(rule ((Let (Var "x") (I 0)) (= t (S "foo")))
      ((let f (unstable-fresh! Math))
       (set (rfoo f) ())))
(rule ((Let (Var "x") (I 0)) (= t (S "bar")))
      ((let g (unstable-fresh! Math))
       (set (rbar g) ())))
(relation extra_pair (Math Math))
(rule ((rfoo x) (rbar y)) ((set (extra_pair x y) ())))
(fail (check (extra_pair z z)))

; 4) Nested unstable-fresh! calls involving two sorts, with the nested fresh appearing
;    inline inside a constructor application. Check that unstable-fresh! respects
;    sort-specific constructor generation without temporary bindings.
(relation nested_mix (Math Math))
(rule ((Let (Var "x") (I 0)))
      ((let outer (unstable-fresh! Math))
       (set (nested_mix outer (Let outer (unstable-fresh! Math))) ())))
; Ensure no tuple stores identical Math values in both slots.
(fail (check (nested_mix z z)))

; 5) Congruence can later equate fresh results once their query columns unify.
(relation fresh_tag (Math Math))
(rule ((Let (Var "x") (I 0)))
      ((let fx (unstable-fresh! Math))
       (set (fresh_tag fx (Var "x")) ())))
(rule ((Let (Var "y") (I 0)))
      ((let fy (unstable-fresh! Math))
       (set (fresh_tag fy (Var "y")) ())))
; Force the queries for x and y to become congruent, which should merge the fresh values.
(rule ((Let (Var "x") (I 0)) (Let (Var "y") (I 0)))
      ((union (Var "x") (Var "y"))
       (union (Let (Var "x") (I 0)) (Let (Var "y") (I 0)))))

; Run a small number of steps to materialize the relations
(run 1)

; Sanity check
(check (= () ()))
