; fresh! sugar tests with multiple sorts in the query to exercise
; column inference across heterogeneous subexpressions.

(datatype Math
  (Let Math Math)
  (Var String)
  (I i64)
  (S String))

; Seed facts so rules have matches
(let seed_x0 (Let (Var "x") (I 0)))
(let seed_y0 (Let (Var "y") (I 0)))
(let seed_x1 (Let (Var "x") (I 1)))

; 1) Difference only in a String-typed subexpression inside the query
;    (Var "x") vs (Var "y"). If String subexpressions are included,
;    these fresh values should be different.
(relation rx (Math))
(relation ry (Math))
(rule ((Let (Var "x") (I 0)))
      ((let a (fresh! Math))
       (set (rx a) ())))
(rule ((Let (Var "y") (I 0)))
      ((let b (fresh! Math))
       (set (ry b) ())))
(relation str_pair (Math Math))
(rule ((rx x) (ry y)) ((set (str_pair x y) ())))
; No pair should have equal components if the String literal participates
(fail (check (str_pair z z)))

; 2) Difference only in an i64-typed subexpression inside the query
;    (I 0) vs (I 1). If i64 subexpressions are included, these fresh
;    values should be different.
(relation r0 (Math))
(relation r1 (Math))
(rule ((Let (Var "x") (I 0)))
      ((let a (fresh! Math))
       (set (r0 a) ())))
(rule ((Let (Var "x") (I 1)))
      ((let b (fresh! Math))
       (set (r1 b) ())))
(relation i64_pair (Math Math))
(rule ((r0 x) (r1 y)) ((set (i64_pair x y) ())))
(fail (check (i64_pair z z)))

; 3) Difference in an additional String-typed fact that is not a subterm of
;    the matched Let node. Column inference must include subexpressions from
;    all query facts, not just the main pattern.
(relation rfoo (Math))
(relation rbar (Math))
(rule ((Let (Var "x") (I 0)) (= t (S "foo")))
      ((let f (fresh! Math))
       (set (rfoo f) ())))
(rule ((Let (Var "x") (I 0)) (= t (S "bar")))
      ((let g (fresh! Math))
       (set (rbar g) ())))
(relation extra_pair (Math Math))
(rule ((rfoo x) (rbar y)) ((set (extra_pair x y) ())))
(fail (check (extra_pair z z)))

; Run a small number of steps to materialize the relations
(run 1)

; Sanity check
(check (= () ()))

