; Binary Decision Diagrams are if-then-else trees/ compressed tries that hash cons their leaves
; This is easily expressible in the facilities provided. Everything in egg-smol is automatcally shared
; and Compression is easily expressible as a rule.

; They are a notion of first class set useful for certain classes of uniformly describable sets.
; https://en.wikipedia.org/wiki/Binary_decision_diagram
; https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf Type-Safe Modular Hash-Consing - Section 3.3

(datatype BDD
    (ITE i64 BDD BDD) ; variables labelled by number
    (True)
    (False)
)

; compress unneeded nodes
(rewrite (ITE n a a) a)

(function and_ (BDD BDD) BDD)
(rewrite (and_ (False) n) (False))
(rewrite (and_ n (False)) (False))
(rewrite (and_ (True) x) x)
(rewrite (and_ x (True)) x)
; We use an order where low variables are higher in tree
; Could go the other way.
(rewrite (and_ (ITE n a1 a2) (ITE m b1 b2))
    (ITE n (and_ a1 (ITE m b1 b2)) (and_ a2 (ITE m b1 b2)))
    :when ((< n m))
)
(rewrite (and_ (ITE n a1 a2) (ITE m b1 b2))
    (ITE m (and_ (ITE n a1 a2) b1) (and_ (ITE n a1 a2) b2))
    :when ((> n m))
)
(rewrite (and_ (ITE n a1 a2) (ITE n b1 b2))
    (ITE n (and_ a1 b1) (and_ a2 b2))
)

(define b0 (ITE 0 (True) (False)))
(define b1 (ITE 1 (True) (False)))
(define b2 (ITE 2 (True) (False)))

(define b123 (and_ b2 (and_ b0 b1)))
(define b11 (and_ b1 b1))
(define b12 (and_ b1 b2))
(run 5)
(extract b11)
(extract b12)
(extract b123)
(check (= (and_ (ITE 1 (True) (False)) (ITE 2 (True) (False)))
       (ITE 1 (ITE 2 (True) (False)) (False)))
)
;(check (= b123 (ITE 3 ()))

(function or_ (BDD BDD) BDD)
(rewrite (or_ (True) n) (True))
(rewrite (or_ n (True)) (True))
(rewrite (or_ (False) x) x)
(rewrite (or_ x (False)) x)
(rewrite (or_ (ITE n a1 a2) (ITE m b1 b2))
    (ITE n (or_ a1 (ITE m b1 b2)) (or_ a2 (ITE m b1 b2)))
    :when ((< n m))
)
(rewrite (or_ (ITE n a1 a2) (ITE m b1 b2))
    (ITE m (or_ (ITE n a1 a2) b1) (or_ (ITE n a1 a2) b2))
    :when ((> n m))
)
(rewrite (or_ (ITE n a1 a2) (ITE n b1 b2))
    (ITE n (or_ a1 b1) (or_ a2 b2))
)

(define or_121 (or_ b1 (or_ b2 b1)))
(run 5)
(extract or_121)

(function not (BDD) BDD)
(rewrite (not (True)) (False))
(rewrite (not (False)) (True))
(rewrite (not (ITE n a1 a2)) (not (ITE n (not a1) (not a2))))

(function xor (BDD BDD) BDD)
(rewrite (xor (True) n) (not n))
(rewrite (xor n (True)) (not n))
(rewrite (xor (False) x) x)
(rewrite (xor x (False)) x)
(rewrite (xor (ITE n a1 a2) (ITE m b1 b2))
    (ITE n (xor a1 (ITE m b1 b2)) (or_ a2 (ITE m b1 b2)))
    :when ((< n m))
)
(rewrite (xor (ITE n a1 a2) (ITE m b1 b2))
    (ITE m (xor (ITE n a1 a2) b1) (or_ (ITE n a1 a2) b2))
    :when ((> n m))
)
(rewrite (xor (ITE n a1 a2) (ITE n b1 b2))
    (ITE n (xor a1 b1) (xor a2 b2))
)


