(datatype Context
    (Str String))

(let $basectx (Str "base"))

(datatype Expr
   (App2 String Expr Expr)
   (Var String))

(constructor Refines (Context Context))

(rule ((Refines a b)
       (Refines b c))
      ((Refines a c)))

(constructor RefinesSym (Context Context))
(rule ((Refines a b))
      ((RefinesSym a b)
       (RefinesSym b a)))


;; A UF is a complete copy of the UF specific to the context.
;; Only stores new unions; it uses leaders from the previous context;
(constructor UF (Expr Expr Context))



;; One way to implement colored egraphs (that missing the point) is to
;; copy all the egraphs for each context.


;; Colored egraphs are a set of optimizations. We can do a weaker version.
;; Make the base context (black) special, and all contexts use representatives from the base context eclasses.
;; If a color does not have any unions in a particular eclass, don't store any nodes for that eclass.
;; Otherwise, store the full union find for that eclass in that context.
;; Then you can either:
;; 1) Avoid keeping all e-nodes for the eclass and just store new ones. But then matching is slower because it has to join on the UF.
;; 2) Copy all e-nodes from the eclass to that color.



;; Could possibly work:
;(rule ((= lhs (Add a b ctx1))
;       (= b1 (Add c d ctx2))
;       (UF b1 b' ctx3)
;       (UF b b' ctx3)
;       (!= ctx3 basectx)
;       (IsBaseOrEqual ctx1 ctx3)
;       (IsBaseOrEqual ctx2 ctx3)
;       )

;; but this finds matches in all colors, we just want the earliest one
;; how bad is this in practice?
;; In actual colored egraphs we match bottom up, starting with the base Context
;; We only find new matches using colored jumps


;; base
;; |    \                    \
;; ifif  in other if         in loop


;; Summary of meeting
;; 1) Implementing real colored egraphs is hard due to duplication of matches between multiple colors
;; 2) We could just take the hit and allowed matching the same thing across multiple colors, and copying the union find for all colors (except no need to copy base color)
;; It's unclear if this implementation would actually help things like eggcc
;; might help a lot
;; 3) Another suggestion: once there are lots of colored unions, clone the e-graph

;; benchmark suite was cases from theorem proving

;; how do we get benchmarks into egglog?
;; we could adapt eggcc
;; original paper has a theorem prover with case splits
;;   It finds splits and applies them somehow, would need to replicate

;; Chris uses aegraphs

; (rule (...normal query))

;; base -> 1 -> 2 -> 3


;; f   g
;; |
;; a  

;; The reachable contexts following any equality edge
;; via contexts that are "compatible"
;; Compatible contexts are ancestors or descendents of the current most specific context
(constructor EclassReachableContexts (Expr Context))


;; exampel: black, red, orange
;; matching on black                   1 -r 2 -o 4
;;   red edge 1 = 2                    |o
;;    orange 1 = 3                     3
;;    orange 2 = 4
;;  


;; original rule
;(rule ((App2 a b)
;       (= b (App2 c d)))
;      (...))

(rule ((App2 f a b)
       (= b' (App2 f c d))
       (UF b b' ctx))
       (...))

;; original rule
;; (rule ((App2 "+" b a)
;;        (App2 "-" b a))

;; match on canonical nodes in base equality relation
(rule ((App2 "+" b a)
       (App2 "-" b' a')
       (UF b bleader ctx)
       (UF b' bleader ctx)
       (UF a aleader ctx)
       (UF a' aleader ctx))
      (...))



